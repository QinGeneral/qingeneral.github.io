{"./":{"url":"./","title":"Introduction","keywords":"","body":"简介 谈谈编程、读书。 GitHub： cocos-jsc-endecryptor Cocos JSC 加解密工具 jvm.kotlin 简易版 JVM by Kotlin SmartPic 方便上传图片到图床的 Alfred Workflow Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 10:27:38 "},"AI/AI 产品/ChatGPT.html":{"url":"AI/AI 产品/ChatGPT.html","title":"Chat GPT","keywords":"","body":"ChatGPT 官网：https://chat.openai.com/热度：⭐️⭐️⭐️⭐️⭐️上手难度：⭐️用途：对话是否免费：免费试用，Plus 版本 $20/月是否开源：否 ChatGPT 是由 OpenAI 开发的先进语言模型，能够理解和生成类似人类的文本。它基于 GPT-3.5 架构，这是自然语言处理中变压器架构的一个变种。 该模型通过对互联网上的大量文本数据进行训练，包括书籍、文章和网页等，来学习自然语言处理。ChatGPT 不仅可以生成语言，还可以进行对话，进行文本分类，翻译等多种语言处理任务。它能够根据输入的文本生成连贯、准确且自然的响应，并不断地学习和改进，使其响应更加准确和人性化。 维基百科：https://en.wikipedia.org/wiki/ChatGPT Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/ChatPDF.html":{"url":"AI/AI 产品/ChatPDF.html","title":"Chat PDF","keywords":"","body":"ChatPDF 官网：https://www.chatpdf.com/热度：⭐️⭐️上手难度：⭐️用途：阅读文档是否免费：免费试用，Plus 版本 $5/月是否开源：否 ChatPDF 可以根据你上传的 PDF 文件生成摘要。还可以针对你上传的 PDF 进行提问。辅助你快速了解一个文档的内容。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Civitai.html":{"url":"AI/AI 产品/Civitai.html","title":"Civitai","keywords":"","body":"Civitai 官网：https://civitai.com/热度：⭐️⭐️⭐️上手难度：⭐️用途：绘图 Prompt 分享是否免费：免费是否开源：否 Civitai 是一个平台，人们可以分享和发现资源，用于创造人工智能艺术。用户可以上传和共享他们使用自己的数据训练的自定义模型，或者浏览和下载其他用户创建的模型。这些模型可以与人工智能艺术软件一起使用，生成独特的艺术作品。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Copilot.html":{"url":"AI/AI 产品/Copilot.html","title":"Copilot","keywords":"","body":"Copilot 官网：https://github.com/features/copilot热度：⭐️⭐️⭐️⭐️上手难度：⭐️⭐️⭐️用途：生成代码是否免费：免费试用两个月，之后 $10/月是否开源：否 GitHub Copilot 是一个基于云的人工智能工具，由 GitHub 和 OpenAI 开发，通过自动完成代码来帮助使用 Visual Studio Code，Visual Studio，Neovim 和 JetBrains 的开发者自动生成代码。GitHub 在2021年6月29日首次发布了这个工具，比较适用于 Python、JavaScript、TypeScript、Ruby 和 Go 语言。 维基百科：https://en.wikipedia.org/wiki/GitHub_Copilot 课程资源 GitHub Copilot 实践课（极客时间） 链接：https://time.geekbang.org/opencourse/videointro/100540901 是否免费：免费 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Glarity-Summary.html":{"url":"AI/AI 产品/Glarity-Summary.html","title":"Glarity Summary","keywords":"","body":"Glarity-Summary for Google/YouTube 官网：https://chrome.google.com/webstore/detail/glarity-summary-for-googl/cmnlolelipjlhfkhpohphpedmkfbobjc热度：⭐️⭐️上手难度：⭐️用途：生成 Google 搜索、YouTube 视频摘要是否免费：免费是否开源：开源 https://github.com/sparticleinc/chatgpt-google-summary-extension Glarity 是一款开源浏览器插件，主要功能是利用 ChatGPT 为谷歌搜索、YouTube 视频等网站内容快速生成中文版本的内容摘要，极大提高查找/观看外文网站或视频内容的效率。在 Google 搜索结果中同时显示 ChatGPT 的总结：为您自动总结Google的搜索结果，帮助您无需再逐一点开网站苦苦找寻答案。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/HuggingFace.html":{"url":"AI/AI 产品/HuggingFace.html","title":"Hugging Face","keywords":"","body":"Hugging Face 官网：https://huggingface.co/热度：⭐️⭐️⭐️上手难度：⭐️⭐️⭐️用途：查找 AI 模型是否免费：免费是否开源：开源 Hugging Face 是一家美国公司，开发使用机器学习构建应用程序的工具。最引人注目的是它的 Transformers 库是为自然语言处理应用程序建立的，它的平台允许用户共享机器学习模型和数据集。 维基百科：https://en.wikipedia.org/wiki/Hugging_Face Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Logo Design Lab.html":{"url":"AI/AI 产品/Logo Design Lab.html","title":"Logo Design Lab","keywords":"","body":"阿里 Logo Design Lab 官网：https://logo.aliyun.com/logo#/aigc热度：⭐️上手难度：⭐️用途：设计 icon是否免费：每日免费生成额度，原图下载收费是否开源：否 Logo Design Lab 可以根据提示词和风格生成对应的 Logo，可付费下载或找专业设计师进一步设计，并拥有该图片的版权。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Midjourney.html":{"url":"AI/AI 产品/Midjourney.html","title":"Midjourney","keywords":"","body":"Midjourney 官网：https://www.midjourney.com热度：⭐️⭐️⭐️⭐️⭐️上手难度：⭐️用途：绘画是否免费：免费是否开源：否 Midjourney 由同名研究实验室开发，可根据文本生成图像，于2022年7月12日进入公开测试阶段，使用者可透过 Discord 的机器人指令进行操作。该研究实验室由 Leap Motion 的创办人大卫·霍尔兹负责领导。 维基百科：https://en.wikipedia.org/wiki/Midjourney Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/New Bing.html":{"url":"AI/AI 产品/New Bing.html","title":"New Bing","keywords":"","body":"New Bing 官网：必应热度：⭐️⭐️⭐️⭐️上手难度：⭐️用途：聊天是否免费：免费是否开源：否 新必应(New Bing)是微软推出的一款基于GPT4模型的智能搜索引擎，它不仅可以提供高质量的搜索结果，还可以与用户进行自然语言交互，提供各种有趣和实用的功能。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Notion AI.html":{"url":"AI/AI 产品/Notion AI.html","title":"Notion AI","keywords":"","body":"Notion AI 官网：Notion – Your wiki, docs & projects. Together.热度：⭐️⭐️⭐️⭐️上手难度：⭐️用途：聊天是否免费：基础版免费，商业版 15美元/月是否开源：否 Notion Al是Notion公司开发的一款人工智能工具，它可以为用户提供自动化的数据分析、文本处理和自然语言处理等功能。该工具可以帮助用户更快速、更准确地完成各种任务，从而提高工作效率。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/Stable Diffusion.html":{"url":"AI/AI 产品/Stable Diffusion.html","title":"Stable Diffusion","keywords":"","body":"Stable Diffusion 官网：https://github.com/Stability-AI/stablediffusion热度：⭐️⭐️⭐️上手难度：⭐️⭐️⭐️用途：绘画是否免费：免费是否开源：开源 Stable Diffusion 是 2022 年发布的深度学习文本到图像生成模型。它经过训练后，可以逐步对随机高斯噪声进行去噪以获得感兴趣的样本，主要用于根据文本的描述产生详细图像。扩散模型有一个主要的缺点就是去噪过程的时间和内存消耗都非常昂贵。 维基百科：https://en.wikipedia.org/wiki/Stable_Diffusion Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品/彩云小译.html":{"url":"AI/AI 产品/彩云小译.html","title":"彩云小译","keywords":"","body":"彩云小译 官网：https://fanyi.caiyunapp.com热度：⭐️⭐️上手难度：⭐️用途：翻译是否免费：免费试用是否开源：否 彩云小译（英语：LingoCloud）是一款翻译软件，专注于人工智能翻译领域，有移动端软件和网页版。该软件下载量已突破百万，并与维基百科等网站展开合作。 维基百科：https://zh.wikipedia.org/wiki/%E5%BD%A9%E4%BA%91%E5%B0%8F%E8%AF%91 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"AI/AI 产品汇总.html":{"url":"AI/AI 产品汇总.html","title":"AI 产品汇总","keywords":"","body":"AI 产品汇总 综合 ChatGPT HuggingFace New Bing 编程 Copilot 绘画 Stable Diffusion Midjourney Logo Design Lab Civitai 写作 Notion AI 阅读 Glarity-Summary ChatPDF 翻译 彩云小译 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:33:23 "},"Android/Android Gradle 概要.html":{"url":"Android/Android Gradle 概要.html","title":"Android Gradle 概要","keywords":"","body":"Android Gradle 概要 Android 工程 Gradle 相关文件有： 工程目录下的build.gradle、settings.gradle；各个module目录下的build.gradle。 其中settings.gradle里的内容非常简单,比如： include ':app', ':libraries:lib1' 这里定义了有哪些Gradle工程。 其他build.gradle文件的内容大致包括： buildscript { repositories { mavenCentral() } dependencies { classpath 'com.android.tools.build:gradle:0.11.1' } } apply plugin: 'android' android { compileSdkVersion 19 buildToolsVersion \"19.0.0\" } dependencies { compile *** implemention .... } 各部分代码解释： buildscript { ... } 部分配置了驱动构建的代码。这部分的配置只会影响构建过程的代码，和你的工程没有关系。工程会定义它自己的仓库和相关依赖 apply plugin: 'android'应用Android插件 android { ... } 这部分配置了 android 构建需要的所有参数。这里也是 Android DSL 的入口点。默认情况下，只有编译的目标SDK、构建工具的版本是必需的。就是 compileSdkVersion 和 buildtoolsVersion 两个配置属性。android 元素里的 defaultConfig 负责定义所有的配置；sourceSets属性可以设置代码、资源目录；signConfigs、buildType可以设置签名配置文件、密码、编译类型等内容； dependencies { ... }dependencies 元素是标准 Gradle API 的一部分，并不属于 android 的元素。compile 配置用来编译 main application，它里面的一切都会被添加到编译的 classpath 中，并且也会被打包到最终的 APK 中。除了compile，还有androidTestCompile、debugCompile、releaseCompile来配置不同编译情况的依赖。 Gradle任务 总结于《Android Gradle插件中文指南》 Android使用了和Java同样的约定规则来和其他插件保持兼容，并且又添加了一些额外的引导任务（这些任务都是依赖于其他子任务，而非自己完成对应的工作）: assemble 这个任务会汇集工程的所有输出 check 这个任务会执行所有校验检查 connectedCheck 运行 checks 需要一个连接的设备或者模拟器，这些checks将会同时运行在所有连接的设备上。 deviceCheck 通过 API 连接远程设备运行 checks。它被用于 CI (持续集成)服务器上。 build 这个任务会同时执行 assemble 和 check 任务 clean 这个任务会清理工程的所有输出 Gradle技巧 总结于《Android高级进阶》 Gradle共享变量 平常会遇到多个module的情况，这时module自己单独管理sdk版本比较麻烦，可以使用外部变量的方式来解决问题。 在工程目录下新建common_config.gradle文件，用于公共变量 输入代码如下 project.ext { compileSdkVersion = 23 ... } 工程中各个module的 build. gradle 文件引用全局配置项如下。 apply from: \"${project. rootDir}/common_config.gradle\" android { compileSdkVersion project.ext.compileSdkVersion ... } 在module比较多时，按照第三步的配置就比较复杂。可以在工程目录下的build.gradle中如下配置： subprojects { apply from: \"${project. rootDir}/common_config.gradle\" } 远程仓库 远程仓库包括Maven Central、JCenter。JCenter传输速度快、更加安全的特性，Android Studio 已将JCenter作为默认依赖源。 代码中，添加远程依赖的方式： compile 'de.greenrobot:eventbus:2.4.1' Gradle 会根据上面的依赖配置，向Maven Repository服务器查询是否存在该版本的函数库，如果存在，则会根据服务器类型拼接下载请求url。然后将对应的jar、aar和一些配置、签名文件下载到本地，以供项目使用。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/Android 四大组件 1：Activity.html":{"url":"Android/Android 四大组件 1：Activity.html","title":"Android 四大组件 1：Activity","keywords":"","body":"Android 四大组件 1：Activity 本文包括以下内容（针对Android面试，部分细节略去）： Activity生命周期 Activity四种启动模式及其应用场景 IntentFilter匹配规则 （Activity和Fragment、Service交互会在其他文章中写到） 1. Activity生命周期 onStart、onStop代表着应用是否可见onResume、onPause代表应用是否在前台 启动A: onCreate -> onStart -> onResumeA启动B：A.onPause -> A.onStop （如果B采用透明主题，则A.onStop不会调用）启动B后，返回A：onRestart -> onStart -> onResumeback键：onPause -> onStop -> onDestroyA启动B，A的onPause执行之后，B才启动。在onPause之中做轻量级工作，能加快B的启动速度 onSaveInstanceState（onStop之前调用，和onPause没有必然的先后顺序）onRestoreInstanceState（onStart之后调用，和onResume没有必然的先后顺序）以上两个方法调用条件： 应用被杀死 配置改变（比如手机方向，添加android:configChanged属性后不会触发，会调用onConfiguration函数） Home键、启动新Activity（单独触发onSaveInstanceState） 2. Activity启动模式 四种模式可根据字面意思理解，不过还要注意一些细节 standard 标准模式： 每次启动会创建一个新的Activity A启动B，B会位于A的栈中 默认的启动模式 singleTop 栈顶复用模式 要启动的Activity在栈顶则直接使用，不创建新的Activity 第二次启动在栈顶，会调用onNewIntent、onResume方法，onCreate、onStart不会调用 singleTask 栈内复用模式 要启动的Activity在栈内则直接使用，不创建新的Activity 第二次启动在栈顶，会调用onNewIntent、onResume方法，onCreate、onStart不会调用 可通过TaskAffinity属性指定要启动的Activity将位于的栈名 具有clearTop效果：在栈内，要启动的A之上有B、C，会让B、C出栈，然后复用A singleInstance 单一实例模式 要启动的Activity会新建一个栈，并且此Activity会独占这个栈 注：可以使用 adb shell dumpsys Activity 查看Activity栈信息，来分析Activity启动时栈的情况 应用场景 standard：Activity默认模式，一般Activity都用这个 singleTop：当外界多次跳转到一个页面是可以使用这个模式，比如从一些下拉栏通知界面点击进入一个页面的情景，避免了因为多次启动导致的需要返回多次的情况 singleTask：可用于应用的主界面，比如浏览器主页，外界多次启动时不会受子页面干扰，clearTop效果也会清楚主页面之上的页面 singleInstance：可用于和程序分离的页面，比如通话页面、闹铃提醒页面 注：在A -> B -> C 时，B不要采用singleInstance，否则，退出再打开时，会是B页面（此属性未验证） 3. IntentFilter匹配规则 Intent隐式启动的三个属性：action、category、data 匹配规则action：代码中有一个及以上与“xml过滤规则”中的相同即可category：代码中所有的必须与“xml过滤规则”中的相同data：同action 注：代码中隐式启动时，会默认添加android.intent.category.DEFAULT，所以xml必须含有此属性才能隐式启动Service尽量采用显示启动 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/Android 开发涉及知识的概要.html":{"url":"Android/Android 开发涉及知识的概要.html","title":"Android 开发涉及知识的概要","keywords":"","body":"Android 开发涉及知识概要 基础 Android历史 开发语言：Java、C++ 系统：Android、TV、Wear、Auto、Things 系统架构简介 Android已发布版本及更新 开发环境搭建、建立工程、AndroidStudio简单使用 入门 UI控件【分为布局、组件？】（可细分）；Intent（显，隐）；Notification；Fragment 四大组件：Activity、Service、Broadcast、ContentProvider 多屏幕适配；权限管理；WebView； 网络：WebView、XML、Json、GSON、HTTP（okHttp）； 持久化：SQLite-LitePal、SharedPreference、文件操作；Application；与其他APP交互；后台； 调用硬件：相机、相册、视频、音频、录音、传感器、定位（GPS、网络）、地图（百度）、NFC、蓝牙； 工程目录结构：layout、res、drawable、values：colors，dimens，strings，styles，theme、menu、XML布局、AndroidManifest、build.gradle、assets、SDK版本与兼容 UI组件：TextView、Button、EditText、ImageView、ProgressBar、AlertDialog、ProgressDialog、ListView、RecyclerView，Adapter，ViewHolder、ListView、GridView、View Pager、Nine-Patch图片、布局（Linear、Frame、Relative、Absolute、Fragment？）、自定义控件、DialogFragment、工具栏、菜单、搜索（搜索框、搜索功能） Gradle简单介绍、模拟器、日志使用、简单调试 进阶 编译过程、MaterialDesign：ToolBar，DrawerLayout，NavigationView，FloatingActionButton，SnackBar，CardView，FloatingActionButton，C，APPBarLayout，下拉刷新 Activity生命周期、启动模式、IPC、View事件体系（等于“触摸事件传递机制？）、RemoteView、View工作原理（绘制过程？）、Drawable、动画、Window和WindowManager 四大组件工作过程、消息机制、Bitmap加载和Cache、CrashHandler、JNI、NDK、性能优化、内存泄漏分析-MAT、提高可维护性、Annotation、EventBus、线程（多线程：AsyncTask、子线程更新UI）和线程池、异步、OpenGL、函数式编程、Percent Support Library、Design Support Library Gradle、注解、数据序列化、WebView中Java和JS交互、DataBinding、规范代码、基于开源项目搭建属于自己的技术栈、插件框架机制、推送机制、全局Context、定制自己的日志工具、调试、定时任务、多窗口、Lambda、自定义View（组件）、Looper、Handler、HandlerThread、Message、定制View和Event Android安全、反编译 设计模式 MVP、MVVM、Builder模式 开发工具 IDE：AndroidStudio、Eclipse 调试工具 插件 辅助工具：Git 命令行工具 持续集成 开源项目、开源库 包管理 APP上传、打包、升级 第三方服务 广告、Crash、统计、应用分发、数据存储、推送、分享、便捷登录、Google Play服务 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/Android内存泄漏场景及解决方法.html":{"url":"Android/Android内存泄漏场景及解决方法.html","title":"Android内存泄漏场景及解决方法","keywords":"","body":"Android 内存泄漏场景及其解决方法 本文包括以下内容： 内存泄漏原理 Android内存泄漏发生的情况 检测内存泄漏的工具、方法 如何避免内存泄漏 1. 内存泄漏原理 简单来说，Java的内存泄漏就是对象不再使用的时候，无法被JVM回收。内存泄漏最终会引发Out Of Memory。 在Java中，判断对象是否仍在使用的方法是：引用计数法，可达性分析。 引用计数法就是对每个对象所持有的引用进行计数，计数为0，则没有引用，判断为可回收状态。但是此方法存在的问题是循环引用，即A持有B的引用，B持有A的引用，同时AB不再使用时，无法回收AB，发生内存泄漏。 可达性分析就是从一些GC Root 对象出发，去遍历所含有对象的引用，以此递归。像树一样，从根向树枝查找可达的对象。最后没有标记到的对象即为可回收对象，解决了循环引用的问题。 但是即使采用可达性分析的方法，还是可能由于程序编写的问题引发内存泄漏。总结来说就是长周期的对象持有了短周期对象的引用，导致短周期对象无法回收，引起内存泄漏。 2. Android内存泄漏发生的情况 内存泄漏是否发生的关键在于对象之间生命周期的长短。下面是可能发生内存泄漏的情况： 比较典型的是Activity的Context，包含大量的引用，比如View Hierarchies和其他资源。一旦无法释放Context，也意味着无法释放它指向的所有对象。 静态变量：静态变量的生命周期和应用的生命周期一样长。如果静态变量持有某个Activity的context，则会引发对应Activity无法释放，导致内存泄漏。如果持有application的context，就没有问题（以下例子是指Activity销毁时没有释放的情况） 单例模式：内部实现是静态变量和方法 静态的View：view默认持有Activity的context 静态Activity 监听器：当使用Activity的context注册监听，不再需要监听时没有取消注册。比如传感器的监听等 内部类 匿名内部类：持有外部类引用。匿名内部类和异步任务一起出现时，可能发生内存泄漏。Activity回收时，异步任务没有执行完毕会导致内存泄漏的发生。因为匿名任务类持有Activity引用，当匿名任务类的引用被另一线程持有，导致生命周期不一致的问题，进而导致内存泄漏 匿名的AsyncTask new AsyncTask() { @Override protected String doInBackground(String... params) { // doSomething return null; } }; 匿名的TimerTask new Timer().schedule(new TimerTask() { @Override public void run() { // doSomething } }, 1000); 匿名的Thread或Runnable new Thread() { @Override public void run() { while(true); } }.start(); 非静态内部类：持有外部类引用 Handler：我们知道Handler处理消息是串行的，所以当Activity已经需要回收，但Looper仍有消息未处理完毕时会发生内存泄漏。因为Looper使用ThreadLocal保存，ThreadLocal是静态的，生命周期与当前应用一致。同时Looper持有MessageQueue的引用，MessageQueue持有Handler引用（msg.target），Handler持有外部Activity引用，导致Activity无法回收 非静态内部类有一个静态的实例：非静态内部类持有外部类引用，如果在某个地方有个非静态内部类的静态实例的话，同样会引起内存泄漏 资源对象未关闭：BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源，使用后未关闭会导致内存泄漏。因为资源性对象往往都用了一些缓冲，缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果仅仅是把它的引用置null，而不关闭它们，也会造成内存泄漏 容器中的对象没有清理：集合一般占用内存较大，不及时关闭会导致内存紧张（不会导致内存泄漏，而会导致可用内存大大减少） webview 3. 检测、分析内存泄漏的工具 MemoryMonitor：随时间变化，内存占用的变化情况 MAT：输入HRPOF文件，输出分析结果 Histogram：查看不同类型对象及其大小 DominateTree：对象占用内存及其引用关系 MAT使用教程 LeakCanary：实时监测内存泄漏的库（LeakCanary原理） 4. 如何避免内存泄漏 长周期的对象持有了短周期对象的引用，导致短周期对象无法回收，引起内存泄漏。所以在使用某个对象时，我们需要仔细研究对象的生命周期，当处理一些占用内存较大并且生命周期较长的对象时，可以使用软引用。对于一些资源操作对象，及时关闭。 不要在匿名内部类中进行异步操作 将非静态内部类转为静态内部类 + WeakReference（弱引用）的方式 在 Activity 回调 onDestroy 时或者 onStop 时 移除消息队列 MessageQueue 中的消息 静态变量置null 停止异步任务 取消注册 使用Context时，尽量使用Application 的 Context 尽量避免使用static 成员变量。另外可以考虑lazy初始化 为webView开启另外一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放 及时关闭资源。Bitmap 使用后调用recycle()方法 防止内存溢出的方法 及时清理容器，将集合里的东西clear，然后置为null 使用adapter时，使用ViewHolder来复用convertView 优化数据结构 比如HashMap和ArrayMap，优先使用ArrayMap；优先使用基本类型，而非包装类 减少占内存较大的枚举的使用 采用三级缓存机制：LRUCache 图片压缩：inSampleSize、RGB_565替换RGB_8888 尽量不要在循环中创建大量对象 注： 在C++ 中，内存分配释放有程序员自己管理。内存泄漏发生的情况是，如果有些对象被分配了内存空间，然后却不可达，由于C++中没有垃圾回收机制，导致无法再释放这些内存空间。 对于Java程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。就是说GC是不可控的，基本是透明的。 Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种 强引用(StrongReference)：JVM 宁可抛出 OOM ，也不会让 GC 回收具有强引用的对象 软引用(SoftReference)：只有在内存空间不足时，才会被回的对象 弱引用(WeakReference)：在 GC 时，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存 虚引用(PhantomReference)：任何时候都可以被GC回收，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否存在该对象的虚引用，来了解这个对象是否将要被回收。可以用来作为GC回收Object的标志 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/Android开发知识概要.html":{"url":"Android/Android开发知识概要.html","title":"Android开发知识概要","keywords":"","body":"Android 开发知识概要 Android简介 Android一词最早出现在法国作家维里耶德利尔·亚当1986年发表的《未来夏娃》这部科幻小说中，作者利尔·亚当将外表像人类的机器起名为Android。这就是Android小人名字的由来。 05年，Google低调收购了一家公司。07年，Android系统首次亮相。08年，Google推出Android 1.0。11年，Android系统全球份额位居第一。 自从Android发布以来，凭借开源的优势，迅速占领了市场。又因为使用Java就可以开发Android应用，软件开发者们也迅速的涌入到Android开发的潮流之中。 序言 我从大二开始接触Android，中间断断续续做了几个项目。中间有很长一段时间感觉到了瓶颈，无法进步。所处的状态就是做项目的话能做，该实现的功能一般都实现得了，但是总感觉写的代码灵活性、扩展性方面甚是欠缺。后来静下心对framework源码进行一些学习后，才感觉有所进步，突破了之前的瓶颈，也感觉重回到了一开始进步快速的状态。目前也在继续探索系统源码，思考一些设计模式和架构方面的东西。 另外高人指点或有人一起学习特别重要，而我之前在这方面做得确实不足，希望之后能和大家一起讨论一些问题。 最近在探究Android拉活机制和Android插件化开发。晚点我会整理成文章发出来。之后我也会写一些Android开发中实用的技巧，Android进阶需要掌握的知识和思想，希望能尽快和大家分享和交流。 挖了很多坑，希望填的满。 简单来说，Android开发其实就是编写Java代码，配合xml文件和图片资源，然后打包安装到Android系统的软件。 以下是我总结的Android开发涉及知识的简要内容，供大家参考。 准备 Android历史 Android已发布版本及更新历史 开发语言：Java基础、C++基础（JNI） 系统架构简介 开发环境、AndroidStudio简单使用，AS插件使用，命令行工具 基础 界面：四大组件、布局、UI组件、自定义view、动画 网络：okhttp、Gson等 数据持久化：SharedPreference、SQLite、文件等 进程、线程、同步、异步 辅助开发工具的使用：依赖管理Maven、构建工具Gradle、Crash处理、调试、日志 APP打包、上传、升级 进阶 Framework底层代码角度重新思考Android开发 AIDL、Binder、多进程 事件分发、view handler、looper、MessageQueue 动画细节 性能优化 JNI 开源框架、开源库：OKhttp、EventBus、Retrofit等 注解 优化工具：Hierarchy Viewer、OOM检测优化工具MAT、Lint 设计模式、架构 Activity启动模式、标记位、Intent Filter Service启动、绑定 多线程：AsyncTask、HandlerThread、IntentService 线程池 系统核心机制 AMS、PMS Window和View的关系 四大组件工作过程（Activity启动过程) SystemServer启动过程 其他 需求不同，需要掌握的技术不同 硬件调用相关（传感器、定位等） 持续集成 版本管理Git Material Design 第三方服务： 广告、Crash、统计、应用分发、数据存储、推送、分享、便捷登录、Google Play服务 Android安全、反编译 增量更新、热更新 插件化 学习资源 看 书籍、博客、Android training & guide、源码 写 总结很重要 博客、笔记 一些资源 http://gityuan.com/ CSDN博客：罗升阳、邓凡平、任玉刚 简书上也有很多高质量的博客 基础书籍《Android4高级编程》《第一行代码》《Android 50 hacks》 进阶书籍《Android开发艺术探索》《Android源码设计模式》《Android系统源代码情景分析》 其他书籍《代码大全》《重构》《深入理解Java虚拟机》《Java并发编程》《efficient Java》等 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/Android插件化框架 RePlugin 初探.html":{"url":"Android/Android插件化框架 RePlugin 初探.html","title":"Android插件化框架 RePlugin 初探","keywords":"","body":"Android 插件化框架 RePlugin 初探 为什么要使用Android插件化框架？ 写软件时，软件的扩展性至关重要。而软件的扩展性跟其代码的解耦程度相关。解耦程度大，就是模块化强。解耦程度小，即模块化弱。 插件化框架RePlugin，所做的就是将软件解耦，实现了代码的模块化。这对软件本身的后续开发、功能添加等，是十分有利的。大大降低了扩展软件的成本，代码的清晰度也提高了。 RePlugin带来的好处不止这些，它还给应用提供了“不用更新APP，直接更新、添加功能”的能力。能帮助我们以更低的用户成本，更加快速的进行迭代。 Android插件化框架要解决什么问题？ 从Android的FrameWork结构来看，Android插件化都要解决基本的三个问题： 资源管理，比如drawable、string等资源 四大组件的生命周期，主要是activity、service组件 ClassLoader类加载 目前已经开源的Android插件化框架 开源的插件化框架： Atlas（阿里 点击访问GitHub） VirtualAPK（滴滴 点击访问GitHub） RePlugin（360 点击访问GitHub） 其中，Atlas主要概念是组件化。RePlugin的优点是只hook了一处——ClassLoader。所以稳定性极强，适配十分简单。 RePlugin 两个主要概念 RePlugin分为宿主和插件的概念。一个APP由 1个宿主 + n个插件组成。宿主的主要功能是管理插件的安装、卸载、更新；插件权限管理等等（当然也可以将管理功能作为一个插件）。那APP下的每一个模块就可以对应一个插件。当你需要添加功能、更新功能的时候，直接把新的插件或更新后的插件发布到线上即可。 RePlugin 宿主配置教程 添加 RePlugin Host Gradle 依赖 在项目根目录的 build.gradle中添加 replugin-host-gradle 依赖： buildscript { dependencies { classpath 'com.qihoo360.replugin:replugin-host-gradle:2.2.1' ... } } 添加 RePlugin Host Library 依赖 在 app/build.gradle 中应用 replugin-host-gradle 插件，并添加 replugin-host-lib 依赖: android { // 要配置applicationId defaultConfig { applicationId \"com.qihoo360.replugin.sample.host\" ... } ... } // apply语句必须放置到android标签之后，以读取applicationId属性 apply plugin: 'replugin-host-gradle' dependencies { compile 'com.qihoo360.replugin:replugin-host-lib:2.2.1' ... } 配置 Application 类 让工程的 Application 直接继承自 RePluginApplication。 public class MainApplication extends RePluginApplication { } 在AndroidManifest中配置这个Application。 只需三步就把RePlugin的宿主配置好了，之后即可在宿主的代码中调用RePlugin相关api，启动、管理插件。 注：如果插件需要使用宿主的依赖库，需要在宿主的Application类中加入以下代码把\"插件使用宿主类\"选项打开，默认是关闭 ```Java rePluginConfig.setUseHostClassIfNotFound(true); ``` RePlugin 插件配置教程 项目根目录的build.gradle，添加以下代码 buildscript { dependencies { classpath 'com.qihoo360.replugin:replugin-plugin-gradle:2.2.1' ... } } 在app/build.gradle中，添加以下代码 apply plugin: 'replugin-plugin-gradle' dependencies { implementation 'com.qihoo360.replugin:replugin-plugin-lib:2.2.1' ... } 两步即可将插件配置好。编写插件代码之后，将插件工程导出apk，改名为 [PluginName].jar 放到宿主工程的assets/plugins文件夹，启动APP即可。 注： 配置插件别名时，在插件的AndroidManifest.xml中，添加以下内容即可（和activity标签并列） 插件的版本号即app/build.gradle中配置的 versionCode 更新插件时迭代插件版本号，重启应用，框架会自动重载、更新插件（RePlugin是这样设计的，但是有bug，解决方法见下，新版本的RePlugin已解决此bug但未发布，可自行去官网下载编译） 当前版本的RePlugin框架的bug：更新插件后，重启应用不会自动加载插件。要解决这个bug，需要在APP关闭时，同时将:GuardService进程（这是插件管理进程，默认启动）关闭即可。 compileOnly(provide) : 库只用于编译期，不会打入apk中；implement(compile) : 会打入apk中。在插件使用宿主的依赖库时，只需使用compileOnly即可，可以减小包的体积 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/macOS 下载编译 aosp 源码.html":{"url":"Android/macOS 下载编译 aosp 源码.html","title":"macOS 下载编译 aosp 源码","keywords":"","body":" 最近在读《Android 进阶指北》，开篇就是介绍如何在安装到 VirtualBox 的 Ubuntu 上进行下载和编译 aosp（Android Open Source Project）。由于我的电脑是 macOS，所以首先尝试了在 macOS 上进行下载和编译 aosp，其中碰到了很多问题，所以整理此文出来，给后来人借鉴。同时，也在 Ubuntu 上做了尝试，问题较少，其解决方法也会在最后列出。 实际上，编译最新的 aosp 源码，是支持最新的 mac sdk 11.0 的，但是 android-9.0.0 代码最新支持到 10.13。就会碰到一些问题。 下载编译环境：系统：macOS Catalina 10.15.6aosp 目标编译平台：android-9.0.0_r1 [TOC] 1. 配置 macOS 环境 由于 Git 对区分大小写比较敏感，而下载和管理 aosp 源码用到了 Git。所以首先要划分一块区分大小写的磁盘出来。 创建区分大小写的磁盘 使用一下命令即可创建一块区分大小写、日志式的磁盘。 hdiutil create -type SPARSE -fs ‘Case-sensitive Journaled HFS+’ -size 200g ~/android.dmg 其中 size 根据需要调整，如果只是下载源码，100g 差不多够用。如果要编译就要 200g 及以上。假如后续磁盘空间不够，可以使用以下命令调整已创建的磁盘大小： 注：这里需要注意的是，根据系统不同，创建出的磁盘文件后缀不同，分别可能是 android.dmg.sparseimage 和 android.dmg。所以以下命令执行的对应文件名不一致。 hdiutil resize -size g ~/android.dmg.sparseimage 可以在 ~/.bash_profile 中添加以下两个方法来方便的挂载、卸载磁盘，执行方法前可能需要执行一下 source ~/.bash_profile 导入方法： # mount the android file image function mountAndroid { hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android; } # unmount the android file image function umountAndroid() { hdiutil detach /Volumes/android; } 挂载之后可以在 Finder 或者 磁盘工具 中看到该磁盘，其格式为 MacOS 扩展、区分大小写、日志式磁盘。如下图所示： 另外，在 macOS 中默认同时打开文件数量上限较低，当我们并行编译 aosp 时，可能会超出此上限。所以如果计划并行编译源码（最好是这样，因为代码量实在太多了），就需要设置文件描述符上限，将以下内容添加到 ~/.bash_profile 即可，同样的可能需要执行 source ~/.bash_profile 来使配置生效： # set the number of open files to be 1024 ulimit -S -n 1024 至此，关于磁盘文件相关的内容就设置好了。下面来看一下如何安装下载时会用到的软件。 安装所需软件 安装 Xcode 执行以下命令即可： xcode-select --install 使用 homebrew 安装 Git 执行以下命令安装 homebrew：点击跳转 Homebrew 官网 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 执行以下命令安装、配置 Git： # install git by homebrew brew install git # config git user info git config --global user.name \"Your Name\" git config --global user.email \"you@example.com\" 检查是否已安装 python2.7 aosp 要求 python2.7 版本，python3 则不行。macOS 自带了 python2.7 版本，可以使用以下命令进行检查： python --version 有以下输出即可： Python 2.7.16 安装 jdk8 点击下载 jdk 8，选择 macOS 版本进行下载安装。安装完成之后，运行以下命令进行验证： java -version 下载 repo 工具 aosp 源码是通过 Git 进行管理的，但是由于代码量巨大，单纯使用 Git 已经无法满足日常便捷操作的目标。所以 Google 以 Git 为基础，使用 Python 编写了 repo 这款工具，让开发者可以更方便轻松的管理源码，点击查看 repo 使用详情。 首先，创建 repo 工具存放文件夹。 mkdir ~/bin 然后，下载 repo，并赋予 repo 可执行权限。 curl https://storage.googleapis.com/git-repo-downloads/repo > ~/bin/repo chmod a+x ~/bin/repo 最后，将 repo 工具添加到 PATH 路径，这样我们可以在之后在终端直接进行访问，无需关心 repo 所在路径。在 ~/.bash_profile 添加以下内容即可： export PATH=~/bin:$PATH 至此，相关软件安装完毕。接下来开始下载源码。 2. 使用 repo 下载源码 创建文件夹 首先，进入我们之前创建、并挂载的磁盘，创建并进入 aosp 源码下载文件夹。 cd /Volumns/android mkdir aosp cd aosp 初始化版本库 然后，初始化一个指定版本的 aosp 源码库。如果命令后跟上 -b 参数，则代表初始化指定版本的源码库，否则为默认的 master 分支。分支列表可以参考 aosp 代号、标记和细分版本号。初始化代码如下： # default is master repo init -u https://android.googlesource.com/platform/manifest # define 9.0.0_r1 branch repo init -u https://android.googlesource.com/platform/manifest -b android-9.0.0_r1 如果存在网络问题，可以使用清华镜像源，具体可以参考 AOSP 清华大学开源软件镜像站。这里要注意的是，如果单纯阅读代码使用，使用清华源即可。如果计划编译代码，建议能够使用 Google 官方源就用官方源，因为清华源存在没有同步的问题，可能会造成一些不必要的麻烦。 tips：使用清华源尽量在夜间进行，白天清华源请求量大，下载源码十分容易中断。晚上则比较顺畅。 如有下图输出即为初始化成功： 下载源码 在已经初始化好的 aosp 源码目录下执行以下命令即可开始下载源码。 repo sync 如下图输出即为下载成功： 此时，单单下载 android-9.0.0 的代码已经占用 99G 了。如下图所示。 3. 构建源码 aosp 构建系统简介 aosp 原本是使用 make 进行构建源码。但是由于在 Android 上 make 十分缓慢，易出错等等原因，Google 转而使用由 Go 语言编写的 Soong 构建系统。Soong 是 make 构建系统的替代品，make 构建系统使用 .mk 文件进行书写编译规则，Soong 则是使用 Blueprint 的 .bp 文件书写。.bp 文件是一种类似 JSON 的语法结构，更加简单明了。Soong 最终将 .bp 文件编译成 ninja 文件，进而由 ninjia 进行编译。ninjia 是一种追求编译速度的小型构建系统，其设计目标是嵌入到一个高级构建系统中，追求尽可能快的编译速度。其构建文件可以读懂但是并不适合手动编写——类似于汇编语言，一般是通过将其他高级构建系统的构建文件编译为 ninjia 文件后作为输入。 此时读者可能产生疑问，Google 由 make 转 Soong 不可能是一夜之间发生的，那如何兼容两者呢？答案是，针对原有的 .mk 文件，Google 开发了 kati 系统，将其也编译为 ninjia 文件，再交给 ninjia 进行编译。 总的来说，Soong 是通过解析 .bp 文件为 ninjia 文件，将 .mk 文件通过 kati 编译为 ninjia 文件，最后进行构建的。 如果你想了解更多，以下资源可以参考： Android Make Build System kati Soong Ninja, a small build system with a focus on speed 初始化构建环境 执行 envsetup.sh 脚本来初始化环境，envsetup.sh 会添加一系列命令可供编译使用。 注：编译相关命令需要在 bash shell 下执行，如果你使用了 zsh 等其他 shell，需要执行 bash 进入 bash shell 后再运行构建命令。 source build/envsetup.sh 选择编译的目标系统 lunch 此时输出如下： /Volumes/Windows/aosp » lunch You're building on Darwin Lunch menu... pick a combo: 1. aosp_arm-eng 2. aosp_arm64-eng 3. aosp_mips-eng 4. aosp_mips64-eng 5. aosp_x86-eng 6. aosp_x86_64-eng 7. aosp_car_arm-userdebug 8. aosp_car_arm64-userdebug 9. aosp_car_x86-userdebug 10. aosp_car_x86_64-userdebug ...... Which would you like? [aosp_arm-eng] 输入英文或者序号都可以，因为我的电脑 CPU 是 x86 架构，所以这里选择 aosp_x86-eng 进行编译，这样运行 Android 虚拟机时，速度会比较快。 开始编译 执行 make 命令即可开始编译，如果需要并行构建的话，需要添加 -j 参数，示例命令如下： make # simplify m # multi task m -j16 在编译的时候会碰到很多问题，其解决方法见下一节一一道来。编译成功最后会打印 build completed successfully。 运行模拟器 如果刚刚编译完，直接执行 emulator 即可。否则需要重新执行 source build/envsetup.sh; lunch aosp_x86-eng; 导入 emulator 命令。 emulator 最后成功运行起来了自己构建出来的 Android 虚拟机了！ 4. 可能碰到的问题及其解决 问题一：Could not find a supported mac sdk 问题详情输出如下： internal error: Could not find a supported mac sdk: [“10.10” “10.11” “10.12” “10.13”] ninja: build stopped: subcommand failed. 执行 ls /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs 发现，MacOSX.sdk 之外，还有一个与其对应的 MacOSX10.15.sdk 软链接。说明本机的 mac sdk 为 10.15 版本。 解决方法： 修改 build/soong/cc/config/x86_darwin_host.go 文件，在 darwinSupportedSdkVersions 下添加 “10.15”,（记得带英文逗号）。 问题二：执行上述操作后，重试编译报错 报错详情如下： ld: symbol(s) not found for architecture i386 其原因是，aosp 并没有支持所有的 mac sdk 版本。比如说我电脑的 mac sdk 版本 10.15，相关配置文件 build/soong/cc/config/x86_darwin_host.go 中的配置如下： darwinSupportedSdkVersions = []string{ \"10.10\", \"10.11\", \"10.12\", \"10.13\", 从这里可以看到官方测试通过、支持的 mac sdk 为上述几个版本。而更新的版本是不支持的。 最终在 Unable to make AOSP systemimage on macOS Mojave 找到了解决问题的答案。 解决方法： 去 phracker/MacOSX-SDKs 下载 10.13 版本。解压后放置到 Mac sdk 文件夹 /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs 下。 问题三：执行上述操作后，重新编译又回到问题一 其原因应该是 aosp 编译系统查找 mac sdk 的规则问题，使用以下方法可以欺骗一下构建系统。 解决方法： 移除现有的 MacOSX10.15.sdk 软链接，执行以下命令来给之前复制进来的 10.13 sdk 创建一个名为 MacOSX10.15.sdk 的软连接，来冒充 10.15 sdk。最后这个问题终于解决。 这里不能够通过在 Finder 中创建替身的方式来创建软链接。 cd /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs sudo ln -s MacOSX10.13.sdk MacOSX10.15.sdk 参考资料：android - Running AOSP build on Mac (Yosemite and later) - Stack Overflow。 问题四：sepolicy_tests_intermediates/sepolicy_tests error 问题详情如下： ... [ 89% 64112/71309] build out/target/pr...icy_tests_intermediates/sepolicy_tests FAILED: out/target/product/generic/obj/ETC/sepolicy_tests_intermediates/sepolicy_tests ... 其原因是 libc++_static 库被重复引入了。删除 system/sepolicy/tests/Android.pb 文件中的 libc++_static 那一行即可。后来有提交修复了该问题，点击查看该提交的 diff。其改动如下图： 参考资料：点击跳转 参考资料 《Android 进阶指北》 Releases · phracker/MacOSX-SDKs · GitHub AOSP 清华大学开源软件镜像站 在解决问题过程中 Google、StackOverflow 帮助很大，感谢 注：一些资料已在文中列出在此不再累述 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/RePlugin 插件启动源码分析.html":{"url":"Android/RePlugin 插件启动源码分析.html","title":"RePlugin 插件启动源码分析","keywords":"","body":"RePlugin 插件启动源码分析 大年初一，先祝各位新年快乐！今天还在看博客学习的兄dei很强大，如果能把一年节日假期时间分配到自己成长上，那你的一年 = 别人一年 * 1.1。如果能够做到年年如此，10年后你就相当于活了11年。而这期间，学习复利效应的效果是呈现指数增长的。当然，朋友关系也不能落下，但在节假日做无聊的事情就是浪费时间了。 之前搭建了RePlugin源码阅读环境，详情请参考博客RePlugin阅读源码环境搭建 。 今天来分析一下RePlugin启动插件（RePlugin.startActivity）的流程。 下图是我用StarUML画的时序图-SequenceDiagram，简单表现了RePlugin.startActivity调用后发生的事情及其先后顺序。 下面进行详细分析。 1. RePlugin.startActivity RePlugin中启动插件，就是通过调用以下方法。 RePlugin.startActivity(context, intent); // 或者 RePlugin.startActivity(context, intent, pluginName, activity); RePlugin是一个有很多静态方法的类。集成了安装卸载插件、启动插件等功能。使用RePlugin框架，一般来说只需要操作RePlugin类就行。 2. Factory.startActivityWithNoInjectCN 这两个startActivity方法，最终都会调用 Factory.startActivityWithNoInjectCN(context, intent, plugin, activity, process); 但startActivity(context, intent, pluginName, activity)方法，中间多了一步，就是给intent设置ComponentName。会先调用以下方法初始化componentName，然后调用startActivityWithNoInjectCN方法。 Factory.startActivity Factory是框架内部的一个工具类，主要集成了查询插件、查询插件资源、查询Activity信息、加载插件等功能。在启动插件中，Factory中所做的工作就是设置ComponentName给Intent。其中ComponentName主要包括两个属性：pkgName和clsName。这两个属性和插件属性对应关系：pkgName == pluginName、clsName == activityName。 ```Java boolean result = sPluginManager.startActivity(context, intent, plugin, activity, process); RePlugin.getConfig().getEventCallbacks().onStartActivityCompleted(plugin, activity, result); 第二行是调用RePluginConfig的方法回调，告知已经启动Activity。这里的RePluginConfig回调，是可以在自己宿主的application中设置的。设置回调后，就可以在application中进行各个事件的处理，比如插件安装失败事件回调方法```onInstallPluginFailed```。以官方samplehost代码为例，设置回调的代码如下。 ```Java // SampleApplication.java repluginConfig.setEventCallbacks(new HostEventCallbacks(this)); 3. PluginCommImpl.startActivity 在Factory.startActivityWithNoInjectCN中，调用了pluginCommImpl.startActivity方法，而在此方法中没有做任何实质的工作，直接调用了PluginLibraryInternalProxy.startActivity方法。 4. pluginLibraryInternalProxy.startActivity PluginLibraryInternalProxy是最终实现启动插件的地方，也是做了最多工作的地方。流程图见下图。 在PluginLibraryInternalProxy中，先判断download标签和plugin是否为null。download标签默认为true，目前没有手动修改的办法。如果判断成立，则回调application中的方法。 然后判断是否是动态类，是的话设置Intent、启动Activity即可。否则进入下一步。 如果插件还没有加载，调用onLoadLargePluginForActivity方法加载插件。然后初始化ComponentName，设置Intent，调用context.startActivity启动插件中指定的Activity。最后调用回调方法，通知application已经启动完毕。 总结 这样来看，RePlugin启动插件，也就是RePlugin.startActivity方法的调用过程，最终还是调用context.startActivity方法实现的。RePlugin框架所做的就是对Activity的pkgName、activityName进行处理：使用这两个属性创建ComponentName，并传递给Intent；以及在启动插件的不同时期，对RePluginConfig的回调，如未找到插件时会回调onPluginNotExistsForActivity方法。 最后，RePlugin启动插件可以说是RePlugin框架源代码的入口，接下来会对插件安装、卸载等功能的源码进行分析，以此一步步的对RePlugin框架整体建立系统的认识，对RePlugin的实现机制有所了解。学习框架中的设计模式，最终能够应用到自己的代码中去。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/RePlugin 插件管理与权限管理.html":{"url":"Android/RePlugin 插件管理与权限管理.html","title":"RePlugin 插件管理与权限管理","keywords":"","body":"Replugin 插件管理与权限管理 插件化能够提高我们程序的拓展能力，提高灵活性。Android中比较有特点的一个插件化框架是RePlugin。 RePlugin分为宿主和插件的概念。一个APP由 1个宿主 + n个插件组成。宿主的主要功能是管理插件的安装、卸载、更新；插件权限管理等等（当然也可以将管理功能作为一个插件）。那APP下的每一个模块就可以对应一个插件。当你需要添加功能、更新功能的时候，直接把新的插件或更新后的插件发布到线上即可。 插件入门教程请 点击查看。 本文包括以下内容： 插件安装、更新、卸载 线上插件：服务器管理插件信息 插件权限管理 1. 插件安装、更新、卸载 插件的基础操作包括插件的安装、更新、卸载等，RePlugin不支持插件的降级。RePlugin对此进行了很好的封装，仅需调用以下代码。 RePlugin中的插件分为外置插件和内置插件。内置插件即随应用安装包（宿主）附带的、在工程app/src/main/assets/plugins文件夹中的插件，内置插件的名称格式为[插件名].jar，文件名即为程序中的插件名。外置插件即应用运行时从sdcard安装的插件。另外，内置插件更新后也会变成外置插件。 安装与升级 插件的安装与升级是调用同一代码即可。如果插件正在运行，则不会立即升级，而是“缓存”起来。直到所有“正在运行插件”的进程结束并重启APP后才会生效。 RePlugin.install(\"sdcard路径\"); 另外可以在插件安装之后加入以下代码，提前释放插件的文件，提高插件的启动速度。因为在插件安装更新之后，不做任何操作，第一次启动会很慢。 PluginInfo pluginInfo = RePlugin.install(\"插件sdcard路径\"); if (pluginInfo != null) { RePlugin.preload(pluginInfo); } 卸载 要卸载插件，则需要使用 RePlugin.uninstall方法。只需传递一个“插件名”即可。 RePlugin.uninstall(\"pluginName\"); 启动 调用以下代码启动插件中的Activity RePlugin.startActivity() 建议在用户第一次启动应用时，主动对所有的内置插件调用 preload 方法，并在界面显示处理进度。否则，用户每当第一次打开应用中的插件时，框架会先解压插件，耗时比较长 2. 线上插件 为了让应用真正拥有灵活更新其功能的能力，就需要把一些插件放到服务器上，按需下载、安装插件。 服务器端就不再详说，主要是可以查看插件列表，下载插件，插件权限管理等功能。下载功能的简单实现可以参考博客 Tomcat文件下载服务器 主要说一下服务器插件信息的数据结构，当然不同的需求有不同的结构。 [{ \"showName\": \"插件展示给用户的名字\", \"realName\": \"程序中的插件名\", \"isBuiltIn\": \"是否内置\", \"updateInfo\": \"更新信息\", \"iconTypeAndName\": \"插件图标名字mipmap/ic_launcher\", \"version\": \"插件版本号\", \"host2PluginActivities\": [ { \"name\": \"插件中可以被启动的activity\" } ] }, ... ] 3. 插件权限管理 当一个应用需要对不同用户控制其权限时，就要在服务器端对插件的权限进行管理。比如说公司内部软件需要对不同角色的人员给与不同的功能，限制其对其他部门功能的使用。 简单描述一下插件的权限管理功能。主要就是实现能够控制不同用户使用不同组合的插件。 可以采用以下的关系： 就是说“权限”是插件和用户的连接点，每个插件拥有一个对应的权限，一个用户拥有多个角色，一个角色对应多个权限。 那我们首先需要有三张表：用户表、角色表、插件信息表。我对三张表的处理和说明如下 用户表 用户表在插件管理中拥有字段 repluginRole 即可，代表用户的插件角色。 角色表repluginRole 字段 说明 id 角色id roleName 角色名称 permission 所拥有的权限 插件信息表 repluginPluginInfo 这里简化其他字段，只保留插件权限相关字段 字段 说明 id 用户id requirePermission 插件要求的权限 isOnline 插件是否在线，即是否发布 那么去服务器获取某员工插件列表的过程如下： 获取该员工的角色，repluginRole字段 通过repluginRole获取该角色所拥有的权限列表 获取插件列表，用上一步的权限列表去匹配各个插件的权限，如果isOnline为true（插件已上线）且拥有插件权限就放入插件列表 Tips目前RePlugin存在bug（2.2.1版本），即安装、更新插件并重启App关闭后，读取插件信息出错，无法加载刚刚更新的插件。 解决： 关闭应用时，手动杀死：GuardService进程即可。GuardService进程为RePlugin框架后台处理插件安装等操作的进程。官方回复，2.2.2版本已经修复，但还未放出此版本。 在Host工程的app module对应的build.gradle中设置persistentEnable = false，使用主进程为插件管理进程。这样做的原理同上，在关闭APP的时候关闭框架的插件管理进程。但是我这样做的时候这会导致APP启动特别慢，运行卡顿，还可能会崩溃。推荐用方法1，虽然这样做需要去处理各种APP关闭的情况。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/RePlugin 阅读源码环境搭建.html":{"url":"Android/RePlugin 阅读源码环境搭建.html","title":"RePlugin 阅读源码环境搭建","keywords":"","body":"RePlugin 阅读源码环境搭建 RePlugin是一个开源的Android插件化框架，只hook一处的思想不禁让人想读一下它的源代码。另外了解一下RePlugin的源代码也能够方便自己代码的编写和对设计模式的认识。 RePlugin框架本身是基于AndroidStudio开发的，主要包括两种类型的库： Android Library Gradle 插件 每种库又分为宿主和插件，最后RePlugin包括四部分： replugin-host-gradle replugin-host-lib replugin-plugin-gradle replugin-plugin-lib 可以在官网查看其目录结构和下载源码 点击查看。 本文包括以下内容： 使用AndroidStudio搭建RePlugin源码阅读和编译环境 我的软件版本 下载源码和新建工程 导入RePlugin的4个module 编译修改后的module 导入sample代码，并使用自己的RePlugin 自定义Gradle插件 RePlugin源码阅读环境搭建 0. 我的软件版本 AndroidStudio 3.0 RePlugin 2.2.2 运行系统 macOS High Sierra 1. 下载源码和新建工程 点击去官网下载，或者直接使用终端命令： git clone https://github.com/Qihoo360/RePlugin.git 下载完成后，目录结构如下： 其中除了replugin-sample目录是官方示例代码外，其他目录为框架源码。也是我们需要导入到AndroidStudio进行阅读、修改、编译的代码。 AndroidStudio 新建工程比较简单，不再详述。 2. 导入RePlugin的4个module 4个module的导入方法一致，见下图： 然后选择Source Directory 到RePlugin文件夹下的module文件夹。确定即可。 重复以上步骤四次，将RePlugin的四个module分别导入。导入后，工程结构如下： 其中app是新建工程自带module，其他四个分别对应RePlugin的四个module。 3. 编译修改后的module 其中replugin-host-lib和replugin-plugin-lib为Android Library，可通过 implementation project(':replugin-host-lib') 的方式在同一工程中直接使用，无需导出jar、aar包的过程。但是对于replugin-host-gradle和replugin-plugin-gradle这两个gradle插件，就需要使用先编译再配置引用的方式使用。以replugin-host-gradle为例，过程如下： a. 找到host-gradle的build.gradle文件，添加以下代码，之后点击按钮，同步工程 uploadArchives { repositories { mavenDeployer { //提交到远程服务器： // repository(url: \"http://www.xxx.com/repos\") { // authentication(userName: \"admin\", password: \"admin\") // } //本地的Maven地址设置为/Users/***/repos repository(url: uri('/Users/****/repos')) } } } build.gradle文件所在 b. 编译gradle插件 打开Gradle标签页面，选择replugin-host-gradle下的upload/uploadArchives，这个选项是上一步加入的代码后新增的选项。双击编译，等编译完成后，去配置的文件夹 /Users/**/repos 下查看。 c. 导入sample代码，并使用自己的RePlugin 导入sample代码和之前导入module过程一致，不在累述。 以下是修改配置文件，使用本地RePlugin的过程： 找到工程的build.gradle文件，一般在第一个，修改如下： buildscript { ext.kotlin_version = '1.1.51' ext.repluginHostGradleVersion = '2.2.2' ext.repluginPluginGradleVersion = '2.2.2' repositories { google() jcenter() } dependencies { classpath 'com.android.tools.build:gradle:3.0.0' classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } 我这里使用RePlugin版本均为2.2.2，可自行根据情况修改。以下两个是新加入的内容。 classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.6' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' 然后找到samplehost module的build.gradle文件，在顶部添加以下内容： buildscript { repositories { maven { url uri(\"/Users/****/repos\") } mavenLocal() jcenter() mavenCentral() } dependencies { classpath \"com.qihoo360.replugin:replugin-host-gradle:$repluginHostGradleVersion\" } } 其中uri中的内容为编译gradle插件时配置的本地目录。 最后修改samplehost module的build.gradle文件的dependencies，主要是替换replugin-host-lib依赖，如下： dependencies { compile fileTree(include: ['*.jar'], dir: 'libs') compile 'com.android.support:appcompat-v7:25.3.1' // compile 'com.qihoo360.replugin:replugin-host-lib:2.2.1' implementation project(':replugin-host-lib') } 最后运行samplehost即可。另外，每次修改gradle插件内容后，需要重新uploadArchives编译发布插件到本地，才能在自己的samplehost中使用修改后的插件。 到此，RePlugin源码阅读、修改、编译的环境就搭好了，相对简单。主要是gradle插件的配置。之后就可以探索RePlugin的世界了。 这里涉及到主要是gradle插件，以下说一下自定义gradle插件。 自定义gradle插件 因为已经有写的很好的博客，在此不再重复编写。这篇文章写得十分全面，很有条理。以下内容转自博客，格式稍有修改：huachao1001的简书 我的CSDN博客同步发布：在AndroidStudio中自定义Gradle插件 转载请注明出处：【huachao1001的简书：http://www.jianshu.com/users/0a7e42698e4b/latest_articles】 一直都想好好学习AndroidStudio中的gradle，总感觉不懂如何在AndroidStudio中自定义gradle插件的程序员就不是个好程序员，这次上网查了一下相关资料，做了一个总结~ 1 创建Gradle Module AndroidStudio中是没有新建类似Gradle Plugin这样的选项的，那我们如何在AndroidStudio中编写Gradle插件，并打包出来呢？ (1) 首先，你得新建一个Android Project (2) 然后再新建一个Module，这个Module用于开发Gradle插件，同样，Module里面没有gradle plugin给你选，但是我们只是需要一个“容器”来容纳我们写的插件，因此，你可以随便选择一个Module类型（如Phone&Tablet Module或Android Librarty）,因为接下来一步我们是将里面的大部分内容删除，所以选择哪个类型的Module不重要。 (3) 将Module里面的内容删除，只保留build.gradle文件和src/main目录。由于gradle是基于groovy，因此，我们开发的gradle插件相当于一个groovy项目。所以需要在main目录下新建groovy目录 (4) groovy又是基于Java，因此，接下来创建groovy的过程跟创建java很类似。在groovy新建包名，如：com.hc.plugin，然后在该包下新建groovy文件，通过new->file->MyPlugin.groovy来新建名为MyPlugin的groovy文件。 (5) 为了让我们的groovy类申明为gradle的插件，新建的groovy需要实现org.gradle.api.Plugin接口。如下所示： package com.hc.plugin import org.gradle.api.Plugin import org.gradle.api.Project public class MyPlugin implements Plugin { void apply(Project project) { System.out.println(\"========================\"); System.out.println(\"hello gradle plugin!\"); System.out.println(\"========================\"); } } 因为我本人对groovy也不是特别熟悉，所以我尽可能的用Java语言，使用System.out.println而不是用groovy的pintln \"\"，我们的代码里面啥也没做，就打印信息。 (6) 现在，我们已经定义好了自己的gradle插件类，接下来就是告诉gradle，哪一个是我们自定义的插件类，因此，需要在main目录下新建resources目录，然后在resources目录里面再新建META-INF目录，再在META-INF里面新建gradle-plugins目录。最后在gradle-plugins目录里面新建properties文件，注意这个文件的命名，你可以随意取名，但是后面使用这个插件的时候，会用到这个名字。比如，你取名为com.hc.gradle.properties，而在其他build.gradle文件中使用自定义的插件时候则需写成： apply plugin: 'com.hc.gradle' 然后在com.hc.gradle.properties文件里面指明你自定义的类 implementation-class=com.hc.plugin.MyPlugin 现在，你的目录应该如下： (7) 因为我们要用到groovy以及后面打包要用到maven,所以在我们自定义的Module下的build.gradle需要添加如下代码： apply plugin: 'groovy' apply plugin: 'maven' dependencies { //gradle sdk compile gradleApi() //groovy sdk compile localGroovy() } repositories { mavenCentral() } 2 打包到本地Maven 前面我们已经自定义好了插件，接下来就是要打包到Maven库里面去了，你可以选择打包到本地，或者是远程服务器中。在我们自定义Module目录下的build.gradle添加如下代码： //group和version在后面使用自定义插件的时候会用到 group='com.hc.plugin' version='1.0.0' uploadArchives { repositories { mavenDeployer { //提交到远程服务器： // repository(url: \"http://www.xxx.com/repos\") { // authentication(userName: \"admin\", password: \"admin\") // } //本地的Maven地址设置为D:/repos repository(url: uri('D:/repos')) } } } 其中，group和version后面会用到，我们后面再讲。虽然我们已经定义好了打包地址以及打包相关配置，但是还需要我们让这个打包task执行。点击AndroidStudio右侧的gradle工具，如下图所示： 可以看到有uploadArchives这个Task,双击uploadArchives就会执行打包上传啦！执行完成后，去我们的Maven本地仓库查看一下： 其中，com/hc/plugin这几层目录是由我们的group指定，myplugin是模块的名称，1.0.0是版本号（version指定）。 3 使用自定义的插件 接下来就是使用自定义的插件了，一般就是在app这个模块中使用自定义插件，因此在app这个Module的build.gradle文件中，需要指定本地Maven地址、自定义插件的名称以及依赖包名。简而言之，就是在app这个Module的build.gradle文件中后面附加如下代码： buildscript { repositories { maven {//本地Maven仓库地址 url uri('D:/repos') } } dependencies { //格式为-->group:module:version classpath 'com.hc.plugin:myplugin:1.0.0' } } //com.hc.gradle为resources/META-INF/gradle-plugins //下的properties文件名称 apply plugin: 'com.hc.gradle' 好啦，接下来就是看看效果啦！先clean project(很重要！),然后再make project.从messages窗口打印如下信息： 好啦，现在终于运行了自定义的gradle插件啦！ 4 开发只针对当前项目的Gradle插件 前面我们讲了如何自定义gradle插件并且打包出去，可能步骤比较多。有时候，你可能并不需要打包出去，只是在这一个项目中使用而已，那么你无需打包这个过程。 只是针对当前项目开发的Gradle插件相对较简单。步骤之前所提到的很类似，只是有几点需要注意： 新建的Module名称必须为BuildSrc 无需resources目录 目录结构如下所示： 其中，build.gradle内容为： apply plugin: 'groovy' dependencies { compile gradleApi()//gradle sdk compile localGroovy()//groovy sdk } repositories { jcenter() } SecondPlugin.groovy内容为： package com.hc.second import org.gradle.api.Plugin import org.gradle.api.Project public class SecondPlugin implements Plugin { void apply(Project project) { System.out.println(\"========================\"); System.out.println(\"这是第二个插件!\"); System.out.println(\"========================\"); } } 在app这个Module中如何使用呢？直接在app的build.gradle下加入 apply plugin: com.hc.second.SecondPlugin clean一下，再make project，messages窗口信息如下： 由于之前我们自定义的插件我没有在app的build.gradle中删除，所以hello gradle plugin这条信息还会打印. 参考资料：http://kvh.io/cn/tags/EmbraceAndroidStudio/ 献上源码：http://download.csdn.net/detail/huachao1001/9565654 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Android/四步准备 Android 面试.html":{"url":"Android/四步准备 Android 面试.html","title":"四步准备 Android 面试","keywords":"","body":"四步准备 Android 面试 各大公司内推进行的如火如荼，再过一段时间就是校招。 面试可以说是学生步入社会的一场考试，只不过是笔试+多次面试（口头考试）的结合体，只要时间不冲突，可以多考几次，秋招不行还有春招。 笔试形式类似在学校的考试。面试相对来说形式新一些，难度更大一些，考察的范围不仅仅是专业知识的掌握，还包括性格、抗压能力、表达能力、随机应变能力等等。 但是归根到底，找工作的过程就是解决一个相对复杂问题的过程。可以按照以下四部进行准备： 定义问题 划分问题 逐个突破 系统化 接下来一步步的看一下具体细节。 1. 定义问题 首先，定义一下我们解决的是什么问题。在这里，因为我们是Android方向，所以可以简单定义为：“我们要找到一个Android方向的工作（或相关的工作），工作要尽量好”。 这个定义很模糊，什么是尽量的好呢？有的人看中薪资，有的人看中五险一金，各种福利等等。在这里，我们不考虑个人主观因素占比较大的问题。我们只考虑更加可控的东西。就是通过个人努力可以获得效果的问题。 我们再思考一下“找到一个Android方向的工作”起决定性的因素是哪一个呢？ 答案是面试。当然一个人过去做过的项目，拿过的奖也至关重要。但是到了这个马上就要面试的时间节点，过去的已经过去，无法改变，能控制的只有现在。没有项目无关紧要，关键的是现在如何准备面试。 目标：我要通过面试，拿到offer（或者我要通过多家公司面试，拿到多家公司的offer，选择最合心意的公司去工作）。当然，这句话表达的太宽泛，并没有什么指导意义。定义问题很重要，而更重要的是如何划分问题，这一步才是具有指导意义，能够落到实践中去的内容。 2. 划分问题 Android面试需要准备内容的大致划分：（括号内为重要程度，最多 5 颗星） Android相关知识、Java相关知识、设计模式（5） 算法、数据结构（5） 如何写简历、如何面试（4） 项目、比赛获奖（4） 操作系统、网络、数据库（3） 细分 以下细分内容，网络等计算机基础方面还不是很全面，持续更新中。 我会逐步更新各个知识点相关博客或资源，如果需要，建议关注。 Android Context的理解 Activity生命周期、启动模式 IntentFilter匹配规则 IPC：Serialzable、Parcelable、Binder、Socket View事件体系 View绘制流程 RemoteViews（不重要） Drawable（不重要） 动画、绘图 window、wm、wms 四大组件启动、工作流程（Activity至少看一下，AMS） 消息机制：looper、handler、MQ 线程、线程池、多线程 bitmap加载、缓存：LRUCache、DiskLruCache、LinkHashMap CrashHandler（一般） multidex（一般） Fragment、Service、SQLite、Webview 内存泄漏：原因、解决方法 ANR的原因、解决方法 开源库（一般要求看过源码，知道原理）：Retrofit、RxAndroid、EventBus、Picasso（优点）、OKhttp3 持续集成Jenkins（不重要） 单元测试、测试用例（一般） 插件化：Atlas、OSGI（一般） Java Java基础：比如接口和抽象类的区别等 Java内存管理：工作内存和主内存等 垃圾回收：回收算法、如何判断对象可以回收、新生代老年代等 并发 锁：sychronized、lock（CAS） volatile 并发集合：CopyOnWriteArrayList、ConcurrentHashMap、RemoteCallbackList（Android的IPC用到）、LinkedHashMap 集合 Map、Set、List Queue、Stack HashMap、HashTable、ConcurrentHashMap：实现原理，区别等 LinkedHashMap 设计模式（六大原则：SOLID + 迪米特） 单例模式：获取各种service 工厂方法：activity、service（onStart） 责任链：Android事件分发 builder：dialog、Picasso 观察者：listview更新、EventBus 适配器：listview adapter 算法、数据结构 排序 冒泡排序 选择排序 归并 堆排序 插入排序 快速排序 希尔排序 桶排序 基数排序 字符匹配：KMP算法 二分查找 二叉树遍历、翻转、重构；二叉查找树 红黑树 AVL树、哈夫曼树、B树（一般） 网络 OSI七层模型、各层功能、各层协议 TCP/IP四层模型 TCP三次握手、四次挥手 TCP、UDP区别 Http、Https区别 操作系统、数据库 线程状态及其切换 线程、进程区别 （数据库重要程度相对低一些，正在整理中，后续会更新） 简历、面试、项目 篇幅较大，会有另外博客进行探讨，敬请关注 3. 逐个突破 可以自己去网上找一些博客、书籍，进行各个知识点的突破，要有耐心，找到一个心仪的工作非一日之功。 一方面，我会陆续更新一些专业知识和面试相关的博客。 另一方面，把我自己的一些资源分享给大家。 博客 GitYuan（gityuan.com）、罗升阳（CSDN）、邓凡平（CSDN）、任玉刚（CSDN） 书籍 Android 4高级编程、Android开发艺术探索、Android源码设计模式、Android 50 hacks、Android应用性能优化最佳实践、Efficient Java、深入Java虚拟机、Java并发编程、Think in Java 刷题 LeetCode、牛客网 4. 系统化 又是一个很大的主题，在另外博客中进行探讨，后续会更新，敬请关注。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"C 语言/浅谈 C 语言 1：编译过程及其可移植性.html":{"url":"C 语言/浅谈 C 语言 1：编译过程及其可移植性.html","title":"浅谈 C 语言 1：编译过程及其可移植性","keywords":"","body":" C 语言作为比较古老的一门语言，当下仍有较大的影响力。根据 TIOBE 语言排行榜数据，C 语言处在第二位。 一方面，几乎所有操作系统的大部分代码都是 C 语言编写的；另一方面，很多高级语言的编译器、虚拟机也是 C 语言编写，比如 Java 虚拟机。当然像 Go 语言这种意图抢占 C 语言市场的系统级语言，企图去 C 语言化，自身编译器使用 Go 语言自身实现，通过自举来证明自己，但也无法忽略初代编译器使用 C 语言的事实。 从“高级语言”的角度来看，C 语言处在比汇编高级，而又比 Java 等语言低级的位置。所谓高级语言，是指程序员在编写代码时的容易程度、代码可读性等方面的区别。高级语言更加容易编写、代码可读性更好，但是运行效率相对来说更低。对于代码编写和可读性的优劣，一方面是指语言特性，比如面向对象、模版、泛型等特性是否支持；另一方面代码的可移植性也十分重要。 Java 虚拟机屏蔽了硬件和操作系统细节，开发者只需编写一次代码，便可以在多平台上运行。相对来说，机器码就必须对应固定架构的指令集才能运行。而只是对机器码简单抽象的汇编语言也是如此，x86 架构的汇编程序无法运行在 arm 架构之上。 要谈 C 语言的可移植性，需要先看一下 C 语言的编译过程。 预处理：对 # 开头的代码进行预处理，如导入头文件内容等； 编译：将预处理后的代码编译为汇编程序； 汇编：将汇编代码编译为机器码； 链接：将上述机器码和其他库文件进行链接，输出可执行程序。 C 语言是通过编译为汇编语言然后编译为机器码执行的。机器码和汇编语言是和硬件架构一一对应，也就是进入汇编步骤之后，就不再有可移植性操作的可能。也就是说 C 语言的可移植性取决于前两步： 预处理：C 语言中存在一些系统调用等和操作系统强相关的代码，因为不同操作系统的系统调用封装是不同的，所以必须通过条件编译来对不同操作系统进行区分，这种情况需要增加开发者的工作量来兼容不同操作系统，所以可移植性并不在这里体现； 编译器：同一份 C 语言代码可以通过不同的编译器，导出不同目标平台的汇编代码，当然要对系统调用、系统库等操作系统相关的代码作处理之后。 也就是说，C 语言在一定程度上是可移植的，但是一般来说，稍微复杂的程序就需要我们对系统库的引用、系统调用等代码作出兼容后才能移植到其他平台。相对于 Java 等语言来说逊色不少。虽说 C 语言编译成机器码后执行效率很高，但是 JVM 的 JIT 和 AOT 技术也大大提升 Java 字节码的执行效率，Java 热点代码的执行效率并不逊于 C。 总结 本文简单介绍了下 C 语言的源代码编译为可执行程序的过程和可移植性。然而这个过程中的编译环节涉及到编译原理的知识，链接环节涉及到可执行程序格式、静态动态链接和符号解析，运行环节涉及到操作系统的 VAS、页表和物理内存寻址，进程等内容。每一块都是计算机基础知识中的重头戏，之后有时间我们再来讨论。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"CocosCreator/CocosCreator 引擎资源加载与释放原理简析.html":{"url":"CocosCreator/CocosCreator 引擎资源加载与释放原理简析.html","title":"CocosCreator 引擎资源加载与释放原理简析","keywords":"","body":"CocosCreator 引擎资源加载与释放原理简析 本文主要内容如下： 资源加载与释放部分代码所在 调试、修改引擎源码的方法 资源加载与释放原理简析 如要了解 CocosCreator 引擎资源加载与释放的原理，调试、修改引擎代码有助于对其原理进行理解。因此文中会先介绍 CocosCreator 引擎各部分及其文件夹，然后介绍调试、修改引擎源码的方法，最后对其原理进行分析。 如果你对阅读、调试修改源码不感兴趣，可直接跳转到第三部分阅读。如果你对此主题不感兴趣，可直接关闭网页。 本文基于 CocosCreator 1.10.2，另外 2.0.8 版本关于资源加载释放部分改动不大，也可适用 前言 Cocos Creator 的引擎部分包括 JavaScript、Cocos2d-x-lite 和 adapter 三个部分，各部分对应源码在（Mac 版）： JavaScript：CocosCreator.app/Resource/engine（JS 引擎） Cocos2d-x-lite：CocosCreator.app/Resource/cocos2d-x（Cococ2d-x 引擎） adapter：CocosCreator.app/Resource/builtin/ 其中 engine 文件夹下代码部分包含了引擎的 JS 层逻辑，而引擎的资源加载与释放部分代码就处于此文件夹中，路径为 cocos2d/core/load-pipeline/，主要涉及 pipeline.js、loading-items.js、CCLoader.js、loader.js、uuid-loader.js 等文件。 另外，需要了解的是 CocosCreator 引擎中资源是有依赖关系的，比如 SpriteAtlas 资源的加载会依赖于多个 SpriteFrame 资源的加载，而 SpriteFrame 资源依赖于 Texture2D 资源。 下边对调试、修改引擎代码做简单介绍。 调试、修改引擎代码 找到 CocosCreator 的 JavaScript 引擎所在目录 CocosCreator.app/Resource/engine，将该文件夹复制到其他地方，我们将对复制后的代码进行调试和修改。然后在 CocosCreator 的项目设置中修改 JavaScript 引擎路径为复制后的路径。如果要调试 Cocos2d-x 部分，修改对应文件夹即可。如下图： 运行以下命令安装编译依赖 # 在命令行中进入引擎路径 cd [engine_path]/engine # 安装 gulp 构建工具 npm install -g gulp # 安装依赖的模块 npm install 现在可以打开 engine 文件夹，对 JS 引擎部分进行修改。修改后，在该文件夹下运行 gulp build 命令即可编译修改的部分，然后刷新 CocosCreator 预览的网页即可 至于调试其源码，可以直接在 Chrome 开发者工具中 Cmd + o （Mac 快捷键）呼出搜索框，输入并打开你需要调试的文件，然后即可打断点进行调试 CocosCreator 引擎资源加载与释放简析 引擎资源加载与释放源码路径为 engine/cocos2d/core/load-pipeline/，主要关注 pipeline.js、loading-items.js、CCLoader.js、loader.js、uuid-loader.js 这几个文件。 其中资源加载涉及 CCLoader、pipeline、loading-items、loader、uuid-loader 等多个类，而资源释放则主要是 CCLoader 中的 release 方法。 资源加载 概括来讲，CCLoader 是供上层直接使用加载、释放资源的类，整合、封装了 pipeline、loading-items、loader 等类；pipeline 包含多个 pipe，这里的 pipe 是指实现了加载资源的单位（如 loader），pipeline 对资源的处理最终是调用 pipe.handle 实现的，pipeline 自身实现的是资源缓存和让资源依次流过管道，即每个资源依次经过每个 pipe 的处理；loading-items 配合 pipeline，实现了加载状态维护、依赖资源入队等内容；asset-loader、downloader、loader 则实现了资源加载具体功能，不同的加载器负责不同资源的加载。 简化来看，一次资源的加载流程底层的调用函数如下： cc.loader.loadRes() CCLoader.load() loading-items.append pipeline.flowIn pipeline.flow pipe.handle（pipe 对应于 asset-loader、downloader、loader） 加载完成，进行回调 加载流程中其实还有一种情况需要注意：loader 其实会根据资源类型将加载任务分发给不同的类，如 uuid 类型会交给 uuid-loader。uuid-loader 加载时会加载该资源的依赖资源，其过程为： uuid-loader.loadUuid uuid-loader.loadDepends pipeline.flowInDeps loading-items.append 后续流程和正常流程一致 以下会根据加载流程分析一下是如何加载资源的。 CCLoader CCLoader 继承自 pipeline，是用户可以直接调用来加载、释放资源的类，它对 pipeline、loading-items、loader 进行了整合封装，并提供了 load、loadRes、loadResDir、release、releaseRes 等方法供用户使用。资源加载相关的便是 load、loadRes 等方法，而所有方法最终是调用 load 方法来进行资源加载的。load 方法如下： proto.load = function(resources, progressCallback, completeCallback) { // 省略部分代码 _sharedResources.length = 0; for (var i = 0; i 可以看到 load 方法中，所做的就是创建一个 LoadingItem，然后对其进行初始化，之后调用其 append 方法。这里 LoadingItem 简单来看就是对待加载资源的一层封装。下边介绍 loading-items。 loading-items loading-items 主要是完善了每个资源对象的属性，包括资源内容、url 地址等，同时维护每个资源的加载状态、依赖关系等。以下是 append 方法代码。 proto.append = function (urlList, owner) { // 省略代码 this._appending = true; var accepted = [], i, url, item; for (i = 0; i 从代码可以看出，append 所做的是：先对资源列表 urlList 里每一个元素做字段完善（create）、依赖处理（registerQueueDep），然后调用 pipeline.flowIn 将所有未加载完成的资源放入 pipeline 之中。下边介绍 pipeline。 pipeline pipeline 包含多个 pipe，pipe 存储在 _pipes 数组中，而且数组中的 nextPipe 赋值给了 lastPipe.next，以此将 pipe 链接成单向链表结构。这里的 pipe 是指实现了加载资源的单位（如 loader），pipeline 对资源的处理最终是调用 pipe.handle 实现的，pipeline 自身实现的是资源缓存和让资源依次流过管道，即每个资源依次经过每个 pipe 的处理。在 CCLoader 初始化 pipeline 时，为它添加了 AssetLoader、Downloader、Loader 三个 pipe，每个资源都会依次经过这三个 pipe 的处理。pipeline 中的 _cache 数组是对每个资源的缓存。 以下是其 flowIn 方法： proto.flowIn = function (items) { var i, pipe = this._pipes[0], item; if (pipe) { // Cache all items first, in case synchronous loading flow same item repeatly for (i = 0; i flowIn 方法所做其实就是：先将每个资源 item 缓存到 _cache 中，然后对每个 item 调用 flow 方法。这里要注意的是 flow 的 pipe 参数为 _pipes[0]，即先将资源交给 pipeline 的第一个 pipe。以下是 flow 方法： function flow (pipe, item) { var pipeId = pipe.id; var itemState = item.states[pipeId]; var next = pipe.next; var pipeline = pipe.pipeline; if (item.error || itemState === ItemState.WORKING || itemState === ItemState.ERROR) { return; } else if (itemState === ItemState.COMPLETE) { if (next) { flow(next, item); } else { pipeline.flowOut(item); } } else { item.states[pipeId] = ItemState.WORKING; // Pass async callback in case it's a async call var result = pipe.handle(item, function (err, result) { // 省略代码 }); // If result exists (not undefined, null is ok), then we go with sync call flow if (result instanceof Error) { item.error = result; item.states[pipeId] = ItemState.ERROR; pipeline.flowOut(item); } else if (result !== undefined) { // Result can be null, then it means no result for this pipe if (result !== null) { item.content = result; } item.states[pipeId] = ItemState.COMPLETE; if (next) { flow(next, item); } else { pipeline.flowOut(item); } } } } flow 方法中对资源的处理分为三部分： 如果资源状态为 ERROR，则直接返回 如果资源状态为 COMPLETE 已完成，如果后续还有 pipe 就将其交给下一个 pipe 处理 如果资源状态为空，说明此资源从未进行加载，则调用 pipe.handle 方法对其进行加载。加载完成后，先将加载结果交给 item，即item.content = result，然后会对其加载状态 states 进行修改，最后如果后续还有 pipe 就将其交给后续 pipe 处理。 接下来再来看一下 pipe.handle 方法。从以下代码可以看出， CCLoader 初始化时，提供了三个 pipe：asset-loader、downloader、loader。实际上 pipe.handle 调用的其实是 assetLoader、downloader、loader 的 handle 方法，下边以 loader 为例进行介绍。 function CCLoader () { var assetLoader = new AssetLoader(); var downloader = new Downloader(); var loader = new Loader(); Pipeline.call(this, [ assetLoader, downloader, loader ]); // 省略代码 } loader loader 是 CCLoader 中添加到 pipeline 的 pipe 之一，其作用就是加载资源，pipeline 会直接调用其 handle 方法来加载资源。类似的类有 asset-loader、downloader。而 loader 相对特殊是它其中又会根据资源类型不同，调用不同的类去实现加载功能。比如 uuid 类型会调用 uuid-loader 来加载。这里提到的 uuid-loader 在加载资源的时候，会去判断资源是否有依赖资源，如果有会将依赖资源添加到 pipeline 中，进而对依赖资源进行加载。 loader 的部分代码如下： var defaultMap = { // Images 'png' : loadImage, 'jpg' : loadImage, 'bmp' : loadImage, // 省略代码 'uuid' : loadUuid, 'prefab' : loadUuid, 'fire' : loadUuid, 'scene' : loadUuid, 'default' : loadNothing }; // 省略代码 Loader.prototype.handle = function (item, callback) { var loadFunc = this.extMap[item.type] || this.extMap['default']; return loadFunc.call(this, item, callback); }; 可以看出 loader 会根据资源类型不同，进而调用对应的类去实现加载功能。如 uuid 类型资源，调用的是 uuid-loader 的 loadUuid 方法。而至于 loadUuid 方法中，则做了 deserialize 资源、解析处理依赖资源等。 资源释放 CCLoader 对于资源释放提供了 release、releaseRes、releaseAsset、releaseResDir、releaseAll 方法，但实际上所有方法最终是调用 release 方法来实现资源释放的，在 release 调用之前所做的就是获取资源对应的 uuid，然后调用 release 方法。以下是 release 方法： proto.release = function (asset) { if (Array.isArray(asset)) { for (let i = 0; i 从代码中可以看到，release 分为两部分： 如果资源是数组，则对数组中的每个元素调用 release 第二部分是释放资源的关键，所做的工作可以简化如下： 获取资源在 pipeline._cache 中的缓存 item，并在 _cache 中移除该 item 拿到资源的实际内容，即 item.content，这也是 loader 加载出来的资源结果。如果 content 是 Asset 类型，则调用其 destroy 方法进行释放，同时释放其依赖的 nativeUrl 资源 如果是 debug 模式，则会在 released-asset-checker 中标记该资源为已释放 注： 这里的 released-asset-checker 是一个辅助类，其中一个作用就是检测已释放资源是否仍被其他资源引用 release 方法其实仍存在缺陷，缺陷之一是无法释放 SpriteAtlas 所依赖的 SpriteFrame 资源，在释放后 SpriteFrame 资源仍存在与 pipeline._cache 中。这导致释放后再次加载同一个 SpriteAtlas 资源的加载不完整问题，该问题的表现是第二次加载 SpriteAtlas 后播放帧动画黑块现象。原因是：加载到 SpriteAtlas 依赖的 SpriteFrame 资源部分时，根据 pipeline.flow 方法代码会发现由于此时 SpriteFrame.states = { \"AssetLoader\": 2, \"Downloader\": 2, \"loader\": 2}，这里 2 代表加载状态 COMPLETE，就是说该资源在所有 pipe 的状态均是已加载完成，资源直接通过了三个管道，最后执行 flowOut 方法，没有继续加载 SpriteFrame 所依赖的 Texture2D 资源，导致显示黑块。 参考文章 引擎定制工作流程 CocosCreator API 文档 本文图片使用 Alfred Workflow：SmartPic 一键上传获取链接，点击查看 SmartPic Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Git/Git 之旅：不那么深入理解 Git.html":{"url":"Git/Git 之旅：不那么深入理解 Git.html","title":"Git 之旅：不那么深入理解 Git","keywords":"","body":" [TOC] 初期形态 代码管理的最早形态是使用类似现在百度同步盘的方式同步、管理代码。但是代码冲突问题时有发生，只能人工解决。 之后出现了改善工具： diff：比较文本文件、目录差异 patch：相当于 diff 反向操作 # 生成差异文件 diff -u hello1 hello2 > diff.txt # 根据 hello1、diff 生成 hello2 cp hello1 hello3 patch hello3 Linus 在 1991～2002 年使用 diff、patch 维护 Linux 代码差异。 diff、patch 缺陷：无法处理二进制文件。Git 解决了此问题。 开山鼻祖 CVS Concurrent Versions System CVS（ConcurrentVersionsSystem）诞生于1985年，是由荷兰阿姆斯特丹 VU 大学的 DickGrune 教授实现的。当时 DickGrune 和两个学生共同开发一个项目，但是三个人的工作时间无法协调到一起，迫切需要一个记录和协同开发的工具软件。于是 DickGrune 通过脚本语言对 RCS（Revision Control System）（一个针对单独文件的版本管理工具）进行封装，设计出有史以来第一个被大规模使用的版本控制工具。 —— 蒋鑫. Git权威指南 (Chinese Edition) (Kindle 位置 559-562). 机械工业出版社. Kindle 版本. CVS 存在的问题： 创建 tag、branch 效率低 tag、branch 分散在 RCS 文件中，不可见 缺乏对合并的追踪，会导致重复合并 不支持原子提交，会导致提交数据不完整 CVS 成功地为后来的版本控制系统确立了标准，像提交说明（commitlog）、检入（checkin）、检出（checkout）、里程碑（tag）、分支（branch）等概念在CVS中早就已经确立。 —— 蒋鑫. Git权威指南 (Chinese Edition) (Kindle 位置 578-579). 机械工业出版社. SVN Subversion SVN 优化了很多特性，如： 实现了原子提交：SVN 不会像 CVS 那样出现文件的部分内容被提交而其余的内容没有被提交的情况 全局版本号：和 CVS 每个文件都拥有一个版本号相比，便捷许多 文件轻拷贝：里程碑和分支创建速度加快很多 这些优化也使得它在版本控制工具中成为最佳选择之一。但 SVN 本质上是一种集中式版本管理工具，这种版本控制太依赖于服务器，如果服务器出现问题，版本控制将不可用；如果网络较差，提交代码将变得十分漫长。 除了以上集中式版本控制系统固有问题之外，再加上 SVN 本身设计的一些问题，使用其进行版本管理也并存在很多不如意之处。比如： 项目文件在版本库中必须按照一定的目录结构进行部署，否则就可能无法建立里程碑和分支 创建里程碑和分支会破坏精心设计的授权 分支太随意从而导致混乱。SVN 的分支创建非常随意：可以基于 /trunk 目录创建分支，也可以基于其他任何目录创建分支，因此 SVN 很难画出一个有意义的分支图。再加上一次提交可以同时包含针对不同分支的文件变更，使得事情变得更糟 Git BitKeeper 和 Git 由来 BitKeeper 是一种分布式版本控制系统。分布式版本控制系统优势：不要中央版本库，每个人都可以自己本地查看提交日志、提交、创建里程碑和分支、合并分支、回退等操作，而不需要网络连接。 分布式版本控制系统和集中式版本控制系统区别粗略的讲，就像是分封制和郡县制的区别。 假设现在要书写史书，集中式即郡县制，郡县制背后是强大的中央集权，相当于中央的史书绝对权威，各个郡县对史书进行修改后必须上报中央才能生效。距离首都近的城市还好，提交修改十分便捷，如果海南要提交对史书的修改，得数月才能跑到首都，进行修改。要想拉取新的分支，写写野史，必须先上报中央，批准后才能进行。这里的离首都的距离，就相当于网速，任何修改、提交、拉分支必须经过网络和中央仓库交互后才能进行。 分布式则相当于春秋战国时期，诸侯做大，诸侯每个人都有一份史书，都可以在自己的国家进行修改。任何修改的提交，甚至想要创建新的分支，写写野史，也无须上报周天子，在自家就可以完成。想同步到周天子时再派人去周天子那里同步一下即可。 这就是集中式和分布式版本控制系统的根本区别。 2005 年发生的一件事最终导致了 Git 的诞生。在 2005 年 4 月，AndrewTridgell（即大名鼎鼎的 Samba - Wikipedia) 的作者）试图对 BitKeeper 进行反向工程，以开发一个能与 BitKeeper 交互的开源工具。这激怒了 BitKeeper 软件的所有者 BitMover 公司，要求收回对 Linux 社区免费使用 BitKeeper 的授权。迫不得已，Linus 选择了自己开发一个分布式版本控制工具以替代 BitKeeper。 —— 蒋鑫. Git权威指南 (Chinese Edition) (Kindle 位置 663-666). 机械工业出版社. Kindle 版本. 基本知识 工作区 Workspace 暂存区 Index/Stage 仓库 Repository 远程仓库 Remote 目录结构 mkdir demo cd demo git init ls -l .git # output # # config # description # HEAD # hooks/ # info/ # objects/ # refs/ description 文件仅供 GitWeb 程序使用，我们无需关心 config 文件包含项目特有的配置选项 info 目录包含一个全局性排除（global exclude）文件， 用以放置那些不希望被记录在 .gitignore 文件中的忽略模式（ignored patterns） hooks 目录包含客户端或服务端的钩子脚本（hook scripts） 剩下的四个文件很重要，是 Git 的核心组成部分： HEAD 文件：指向目前被检出的分支 index 文件：保存暂存区信息 objects 目录：存储所有数据内容 refs 目录：存储指向数据（分支 heads、远程仓库 remotes/origin 和标签 tags 等）的提交对象的指针 接下来通过拆解 git add、git commit、git checkout 命令，结合 HEAD、refs/heads/master、objects/ 文件变化，探索一下 Git 的背后。 实践操作 git checkout : HEAD cat .git/HEAD # output # ref: refs/heads/master git checkout -b test cat .git/HEAD # output # ref: refs/heads/test git add filename : 工作区文件添加到暂存区 # 生成 object git hash-object -w filename # 添加到暂存区 git update-index --add filename # 上述两个命令相当于 git add filename # 查看暂存区 git ls-files --stage # 上述命令相当于 git status git commit : 将暂存区文件提交 # 保存当前目录结构 git write-tree # 保存快照 commit，-p 可指定父快照 echo \"first commit\" | git commit-tree 90f3b20385d2b20cf85477a65e4ef7e2eff71353 [-p id] # git log 无内容，因为当前 HEAD 没有绑定到刚刚提交的快照 git log # HEAD 对应 refs/head/master，将快照 id 放到该文件即可 echo 785f188674ef3c6ddc5b516307884e1d551f53ca > .git/refs/heads/master git log # 以上命令相当于 git commit -m \"first commit\" 总结 objects/ 中的对象类型 blob: git hash-object 生成的为 blob object。命名取自文件的 SHA-1 值 tree: wirte-tree 生成的是 tree object。该对象将多个文件组织到一起 commit: commit-tree 生成的是 commit object。该对象表示一次 commit。 tree 对象相当于 Linux 中的目录，blob 对象相当于 Linux 中的文件。tree 和 blob 关系如下图： refs/heads/master 和 .git/objects 各个类型对象之间的关系： 灰色为 refs/heads/master 文件 绿色为 .git/objects/ 中的 commit object 文件 紫色为 .git/objects/ 中的 tree object 文件 红色为 .git/objects/ 中的 blob object 文件 命令拆解与文件转换关系 git checkout -b test git checkout 切换分支，本质上是对 HEAD 文件的内容修改，令其指向 refs/ 中的不同文件。 git add git add 分为两步： 将工作区中的文件转为 objects/ 中的 blob 对象，并以 SHA1 命名 将该对象的 SHA1 记录到 index 文件中 git commit git commit 分为三步： 根据 index 中的记录，生成 objects/ 中的 tree 对象 根据生成的 tree 对象创建 commit 对象 把 commit 对象的 SHA1 放入 refs/heads/master HEAD、refs/heads/master、objects/ 关系 HEAD 指向 refs/ 中的文件 refs/ 中的文件都是存有某个 commit 对象的 id commit 对象文件中存有 tree 对象的 id、提交作者、提交日志 tree 对象中存有其下的 blob 对象、tree 对象 id 列表和对应文件名 blob 对象中则存有对应文件的内容 问题 Git 是保存差异吗？ 经过实践操作和搜索发现，Git 每次修改文件都会生成一份完整的 blob 文件，而非保存差异。只是会在和远程仓库交互的时候，会进行压缩和差异处理来决定上传差异文件还是完整的文件。 就是说平常 Git 存储的完整文件——松散 loose 对象格式，但是 Git 会时不时对这些文件进行打包，删除原始文件，当向远程服务器推送的时候也会执行这个操作。自己可以执行 git gc 主动触发这一操作。 详细解答可以看：Git 内部原理 - 包文件 参考资料 常用 Git 命令清单 - 阮一峰的网络日志 Git教程 - 廖雪峰的官方网站 Git的诞生 - 简书 Git 原理入门 - 阮一峰的网络日志 How does git work internally. A Friendly introduction | by Shalitha Suranga | Medium Git - 底层命令与上层命令 《Git权威指南》 - 豆瓣 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Git/Git 入门.html":{"url":"Git/Git 入门.html","title":"Git 入门","keywords":"","body":"Git 入门 安装 Git 打开官网 https://git-scm.com/ ， 你可点击对应系统的安装包的下载标识进行下载，然后安装即可。 另外，你还可以通过以下几种方式安装 Git： 在 Linux 系统如 CentOS 下，通过 yum 进行安装 yum install git ；Ubuntu 下通过 apt 进行安装 apt-get install git macOS 下你可通过 homebrew 安装 Git brew install gitmacOS 下安装 git 开始使用 Git 首先使用 git --version 查看一下你安装 git 的版本。 本文中的一些 Git 命令基于 macOS，Git 版本 2.17.1。 配置全局变量 我们需要配置一些 Git 需要的变量，该全局变量会存储在 ~/.gitconfig 或者 /etc/gitconfig 文件中。 配置用户名和邮箱： git config --global user.name \"Your name\" git config --global user.email *@.com 因为有时我们需要经常对 Git 进行操作，所以可以通过设置 Git 命令别名来加快我们操作 Git 的速度： 如果你希望该电脑的所有用户都可以使用配置的命令别名，你可以如下设置将 status 的别名设置为 st，以后运行 git st 即代表 git status ：sudo git config --system alias.st status。如果只想给当前用户添加命令别名，可进行如下设置：git config --global alias.st status 开启 Git 颜色展示： git config --global color.ui true 开启 Git 之旅 我们这里使用 GitExample 文件夹为例。假设我们现在处于该目录下，运行 git init 命令即可初始化一个 Git 仓库。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Git/Git 的诞生.html":{"url":"Git/Git 的诞生.html","title":"Git 的诞生","keywords":"","body":"Git 的诞生 相信各位开发者对Git不会陌生，就算不熟悉Git相信你对GitHub也有所了解。而Git这款在版本管理工具中叱咤风云的软件是如何出现的呢？在Git之前版本管理又是如何发展的呢？在本文里我会对版本控制工具的发展和Git的起源的进行介绍。 我们在开发一款软件时，尤其是多人协作开发，代码的管理是十分重要的。比如个人开发时需要对代码的版本进行管理，多人协作开发时需要一个工具来进行代码的合并、冲突处理、版本管理等等。这样一款工具我们往往称之为“版本控制系统”。 在最初的日子里，我们同步、管理代码可能是通过软盘拷贝、文件服务器（类似现在的云盘）来进行的。但是这种方法丝毫没有处理代码冲突的能力，合并代码只能通过人工手动来操作，这大大消耗了我们的人力和时间。 diff 和 patch 第一次改善这种状况是 diff 和 patch 命令的出现。假如我们现在有两个文本文件 a.txt 和 b.txt。其中 diff 命令可以比较 a.txt 和 b.txt 的文本差异，另外它还可以比较两个文件夹之间的差异。假如我们把差异保存到了diff.txt 中，patch 命令则可以根据 diff.txt 和 a.txt、b.txt 的其中任一文件得出另一文件。这两个工具的出现让我们合并代码的能力得以增强。 CVS 和 SVN 第一个可以管理整个工程的版本工具CVS（ConCurrent Versions System）诞生于 1985年，它是由荷兰一所大学 Dick Grune 教授打造。当时教授在和几个学生协同开发一个项目，但苦于项目代码的合并，于是教授就基于单个文件版本工具 RCS 开发了 CVS。 CVS 采用 C/S 架构设计，服务端来进行版本库的管理工作，服务端通过只保留一份文件拷贝和记录差异使其存储效率大大提高。CVS 也奠定了版本控制工具的模型，CVS中的commit log、tag、branch等属性都在后续出现的版本控制工具中得以延续保留。 可以说CVS是集中式版本管理工具的开山鼻祖。当然CVS也存在很多问题，而正是因此，类CVS版本控制工具大量出现，在一定程度上解决了CVS存在的问题，SVN就是其一。 SVN（Subversion）于2000年由CollabNet资助开发，目标就是取代CVS。SVN优化了很多特性，如实现了原子提交、全局版本号、文件轻拷贝等，这些优化也使得它在版本控制工具中成为最佳选择之一。但SVN本质上是一种集中式版本管理工具，这种版本控制太依赖于服务器，如果服务器出现问题，版本控制将不可用；如果网络较差，提交代码将变得十分漫长。再加上SVN本身设计的一些问题，使用其进行版本管理也并存在很多不如意之处。 Git Git是由Linux之父Linus开发的，在2005年4月3号开始开发，到 4.7 仅四天时间Git就可以投入使用了。到同年6月份，Linux已经在使用Git管理代码了。 Linux版本管理最早是通过手工合并代码的方式进行的，不使用CVS的原因就是Linus坚决反对这种集中式的版本管理工具。而迫于其他开发者的压力，Linus最后决定使用BitKeeper一种分布式的版本管理工具。与集中式不同，使用分布式的版本管理工具每个人都可以在本地进行版本的管理，如日志提交、代码提交、创建tag和分支、合并分支等等操作。 而在2005年4月，Andrew Tridgell 为了开发一个可以与BitKeeper交互的工具，试图反编译BitKeeper。这让开发该软件的公司BitMover得知并取消了Linux社区免费试用BitKeeper的权利。这也成为了Linus开发Git的契机，促进了Git这一伟大作品的诞生。 Git为版本管理打开一扇新的大门，后续我会对Git的入门使用进行介绍，如有兴趣请继续关注。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Java/浅谈 JVM 1：一次编写，到处运行.html":{"url":"Java/浅谈 JVM 1：一次编写，到处运行.html","title":"浅谈 JVM 1：一次编写，到处运行","keywords":"","body":" 不同于 C、C++ 无需运行时可直接编译为机器码运行，Java 程序需要运行在 JRE 之上。而正因如此，Java 拥有了 C、C++ 所不具有的可移植性。而在 JRE 之中，JVM 又是一个重要的组成。 之所以要大费周章地编写 Linux、macOS、Windows 平台的 JVM，其中之一便是因为 Java “一次编写，到处运行” 的设计理念。 打开 Java 官网 可以看到以下内容： Java SE 的每个版本都包含两部分： Java 语言规范； 虚拟机规范。 我们再结合 Java、JRuby 等语言的编译执行过程来看，如下图： 可以看到 Java 官方之所以要将 Java 语言规范和虚拟机规范分别定义，就是为了让多种语言如 Java、JRuby、Jython、Groovy 等都可以运行在 JVM 之上。Java 并不是 JVM 支持运行的唯一语言。 2018 年推出的 GraalVM，更是有一统天下语言运行时之趋势。可以参见 GraalVM 官网。 这其中的关键之一就是 class 文件。任何操作系统上编写的 Java 等语言的代码都可以编译为 class 字节码，然后将其交给不同平台的 JVM 解析、加载、链接、编译、执行。 JVM 除了能够执行 class 文件，让语言能够一次编写多处运行之外。还有以下特性支持： 内存管理 垃圾回收 数组越界等安全保护机制 既然 JVM 执行的是 class 字节码，而非原生 Java 代码。同时又有多种语言可以编译为 class 字节码，而不同语言的特性是不同的。比如 Java 字段类型一旦确定就不许变化，而 JavaScript 字段类型则更加灵活。这就意味着 class 字节码和 JVM 层面必须对多种语言特性进行支持，JVM 执行层面各字段类型不完全等于 Java 代码中的类型，JVM 执行代码的顺序也不完全等于 Java 代码中的顺序。 要想了解 Java 代码真正运行期间发生了什么，我们需要了解 class 字节码格式和 JVM 执行流程。这两者均在 JVM 规范中有所定义。 我们日常开发中让人头疼的问题，在对字节码和 JVM 有一定了解后都会烟消云散。比如： if (flag) 和 if (flag == true) 在字节码层面是否有区别？有何区别？ 如下代码在 try catch 不同代码块调用 return，函数最终返回返回值是什么？为什么会这样？ // 此代码参考《深入理解 Java 虚拟机》代码清单 6-5 public int inc() { int x; try { x = 1; return x; } catch (Exception e) { x = 2; return x; } finally { x = 3; } } 对于重写和重载方法，JVM 调用时如何定位到具体方法？ 对于多态，JVM 又是如何实现？ 关于字节码解读和 JVM 基本原理，我们有时间再继续聊。 推荐资料 《深入理解 Java 虚拟机》 正如《重构》一书是代码重构领域的圣经，此书也是国内理解 JVM 的必读之书。 Java 语言和虚拟机规范官网 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Java/浅谈 JVM 2：如何阅读字节码.html":{"url":"Java/浅谈 JVM 2：如何阅读字节码.html","title":"浅谈 JVM 2：如何阅读字节码","keywords":"","body":" 上文聊到理解字节码和 JVM 执行过程能够帮助我们日常开发中解决疑难杂症。这次，我们先来看看如何阅读字节码。 字节码文件是我们使用 javac xxx.java 编译而来的 xxx.class 文件，内容为 8 bit 字节流。class 中的数据类型有 u1、u2 和 u4。u1 代表该数据占用 1 字节，u2 代表 2 字节，以此类推。 每个 class 文件包含了一个类、接口、模块的定义。这些字节流所代表的内容结构由一个类似 C 语言结构体 structure 的数据结构来定义，该定义在虚拟机规范中给出，结构如下。结合该结构我们即可对照 class 字节流反编译出该类的内容。 摘录自 Java Virtual Machine Specification。 ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } 1. 示例代码 本次我们就以简单的 Demo.java 来介绍阅读字节码流程和如何理解字节码。请先查看以下代码， public class Demo { private int mThisIsInt = 1024; public static void main(String[] args) { System.out.println(\"hello world\"); } private int getThisIsInt() { return mThisIsInt; } } 2. 编译为 class 字节码 执行 javac Demo.java 即可得到 Demo.class 文件。这是我们本次要阅读分析的目标文件。 3. 解读字节码 使用 hexdump VSCode 中提供了 hexdump 插件，展示字节码的 16 进制数据。安装该插件后，在 VSCode 中我们右键反编译出的 Demo.class 文件，选择 Show Hexdump 选项，即可看到如下内容。 我们可以开始对照上文中的 ClassFile Structure 来解读该内容。 magic 部分 ClassFile 结构告诉我们，第 1 部分内容为 magic，u4 代表占用四字节，对应 CAFEBABE 内容，这部分内容用来标识 Java 字节码文件格式，可以看到 Java 图标的源头在此处。 version 部分 第 2、3 部分内容为 minor_version 和 major_version，分别占用 2 字节，对应 0000 和 003A 部分内容。代表此 class 文件主要版本为 58，次要版本为 0。此版本标识和 JDK 版本相关联，具体可参考 Java Virtual Machine Specification 表 4.1-A。 constant_pool 部分 第 4、5 部分内容为 constant_pool_count 和 constant_pool。代表常量池相关内容，constant_pool_count 标明常量池数量，等于 constant_pool 中的 item 数量。constant_pool 则用于存储每个常量。其结构为 cp_info。内容如下所示。即由两部分组成，1 字节的 tag，代表 cp_info 类型，比如 7 代表 Class——类，9 代表 Fieldref——字段。 cp_info { u1 tag; u1 info[]; } 在此以 Methodref 为例。一个方法的结构描述如下。 CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; } tag 为 10，代表 Methodref 类型； class_index 是指向常量池中 CONSTANT_Class_info 类型数据的索引，代表当前方法属于哪个类； name_and_type_index 是指向常量池中 CONSTANT_NameAndType_info 类型数据的索引，代表方法的名称和描述符，描述符则描述了方法的参数和返回值类型。 这时直接阅读字节码 16 进制数据已变得繁琐。在此，我们借用另外一个工具，来进一步解释常量池和其索引的方式。 使用 javap 执行 javap -v -p Demo.class 获取到可读性更强的反编译文件。我们先查看一下 Constant pool 中的部分内容。 // 省略内容... Constant pool: #1 = Methodref #2.#3 // java/lang/Object.\"\":()V #2 = Class #4 // java/lang/Object #3 = NameAndType #5:#6 // \"\":()V // 省略内容... 常量池中使用数组保存每个常量的内容。每个常量都有自己的索引，javap 反编译出的文件中使用 #n 表示。 #1 代表一个 Methodref 方法类型常量，该常量通过引用 #2 #3 号常量表示自己。 #2 表示 Object 类。 #3 使用 #5、#6 号常量表示自己。#5 #6 都为 CONSTANT_Utf8 类型，数据内容分别为 和 ()V。代表该方法的名称为 ，没有参数，返回值类型为 void。 由此我们可以得出以下结构。 methods 部分 之后的 access_flags、this_class 等部分，分别表示该类的访问标识、父类、接口、字段等信息，解读方法和常量池类似，不再详细列出。 值得一看的是，method_info 部分。其中包含了类中所有的方法。方法的描述和前文一致，其中的 attributes 属性结构如下。 attribute_info { u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; } 我们方法的代码部分，就在此存储。其 attribute_name_index 指向内容为 Code 的常量，代表此为代码属性。attribute_length 为属性长度，之后的 info 数组则存储了方法代码对应字节码。我们以 Java 代码中 getThisIsInt 方法为例，其 Java 源代码和对应字节码如下。 // Java 代码 private int getThisIsInt() { return mThisIsInt; } // 字节码 private int getThisIsInt(); descriptor: ()I flags: (0x0002) ACC_PRIVATE Code: stack=1, locals=1, args_size=1 0: aload_0 1: getfield #7 // Field mThisIsInt:I 4: ireturn LineNumberTable: line 11: 0 我们重点关注 Code 部分。 stack=1 表示操作数栈的最大深度为 1。 locals=1 表示局部变量表的最大槽数为 1。 args_size=1 表示方法参数的数量为 1。需要注意的是，getThisIsInt 方法没有显示的参数。但是该方法为实例方法，内部可以直接访问 this，因此翻译为字节码时，默认添加了 this 参数提供方法内访问当前对象的功能。也就是说，方法内可以访问 this 是通过给方法添加默认参数实现的。 0: aload_0 1: getfield #7 // Field mThisIsInt:I 4: ireturn 之后便是代码对应的字节码，这部分实现了加载类字段 #7 号常量然后返回的功能。具体的执行流程涉及 JVM 指令集，限于篇幅我们以后有时间再来具体聊聊。 其中行首的 n: 代表字节码偏移，等于当前指令之前所有指令占用的存储大小。比如 getfield #7 之前的 aload_0 指令占用 1 字节，所以其偏移为 1。 LineNumberTable 部分则是字节码偏移和 Java 源代码的对应关系。line 11: 0 表示，Java 源代码第 11 行 return mThisIsInt; 对应代码字节码的 0 号偏移 aload_0 开始的字节码部分。 使用 jclasslib 除了 hexdump 和 javap 之外，我们还可以使用 jclasslib 工具来阅读字节码。使用起来更加直观和便捷。比如提供了常量池索引间跳转、查看 JVM 规范、替换操作码等功能。 jclasslib 既提供了独立的 app 也提供了 IDEA 插件。点击查看 jclasslib Github 和 IDEA 插件。下图为 IDEA 插件截图。 总结 本次我们了解了如何结合 JVM 规范中的 ClassFile Structure，同时使用 hexdump、javap、jclasslib 工具来解读 Java 字节码。 解读过程中，也结合字节码，了解到方法中访问 this 的实现方式。 对于 JVM 指令集和 Code 执行流程，由于篇幅原因我们有时间再来聊。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Java/浅谈 JVM 3：指令集及其执行.html":{"url":"Java/浅谈 JVM 3：指令集及其执行.html","title":"浅谈 JVM 3：指令集及其执行","keywords":"","body":" 上文我们聊了如何参考 JVM 规范 解读 Java 字节码。但对于字节码方法字段 Code 中的 JVM 指令 执行过程我们留下了疑问，这次我们来谈谈。 运行时区域 我们先来看一下更加详细一些的 JVM 逻辑区域划分。 可以看出，在 JVM 中主要划分为 5 块区域： 方法区 Java 堆 程序计数器 Java 栈 本地方法栈 在执行字节码前，虚拟机需要先将 .class 文件加载进来。相关类的信息会存放在 方法区 中。Code 字段的信息就会放在此区域，后续配合 Java 方法栈 执行。 当我们通过 new Ojbect() 或反射等方式创建对象时，JVM 会在 Java 堆 中为对象分配内存。 方法区 和 Java 方法栈 为线程公有内存区域，所以当我们多线程访问同一个对象时，需要进行加锁操作，来处理线程并发处理数据所引发的问题。锁操作的实现，也和指令集相关。 其他三个均为线程私有区域。 程序计数器 保存当前线程中，当前执行的字节码指令位置。 Java 方法栈 为 栈 型数据结构，具有后进先出的特性。其组成元素为 栈帧。每当执行一个方法时，会根据该方法对应的 Code 属性生成对应栈帧，压入到栈中。方法执行完毕时，栈帧出栈。当前正在执行的方法处在栈顶的位置。本地方法栈 和 Java 方法栈 类似，不过它处理的是 C++ 编写的 native 方法。 每个 栈帧 包括局部变量表、操作数栈、动态连接、返回值等内容。动态连接为指向运行时常量池中该栈帧所属方法的引用，目的是为支持方法调用的动态连接。动态连接是 Java 支持动态特性的关键所在，此部分我们之后专门花篇幅介绍，此处先浅尝辄止。返回值则代表当前方法计算结果，返回给上一级调用方法。 局部变量表 用于存放方法参数和内部定义的局部变量。在字节码中方法的 Code 属性定义了 max_locals 属性表示局部变量表的最大容量。局部变量表以 变量槽 为单位存储数据。其实际占用内存空间大小虚拟机规范并未规定，可由虚拟机各自实现。只要求一个变量槽可存储下 boolean、byte、char、short、int、float 等类型数据。所以对于 double、long 类型数据会占用两个变量槽的空间。boolean 在此被使用 0、1 存储。由此可以看出，JVM 中的类型和 Java 代码中的类型并不一致。 操作数栈 也是一个后进先出栈，其最大深度同样在 Code 中有所体现。这块区域供字节码指令调用时使用，保存指令调用所需参数和结果。 运行时栈帧结构和指令集 对于 JVM 指令集，可以参考官方文档。 在此，我们结合一段简单代码，了解一下常见指令集。 Java 代码如下： private int getThisIsInt() { int a = 2; return mThisIsInt * a; } 编译后字节码如下： 0 iconst_2 1 istore_1 2 aload_0 3 getfield #7 6 iload_1 7 imul 8 ireturn iconst_2 将 int 类型常量 2 压栈到操作数栈中 istore_1 将操作数栈的 int 值出栈，放入局部变量表槽位 1 的地方 aload_0 加载局部变量表槽位 0 处的引用到操作数栈中，此处为当前对象的引用 objectref getfield #7 获取当前类的运行时常量池 #7 变量，此指令执行完后，objectref 出栈，获取到的值入栈 iload_1 从局部变量表槽位 1 处加载值到操作数栈中 imul 将操作数栈中靠近栈顶的两个值出栈，做乘法，将结果压栈 ireturn 将当前方法操作数栈中的值出栈，并压栈到调用者方法的操作数栈中 可对照下图梳理指令执行时，局部变量表和操作数栈的变化情况。 JVM 指令集较多，限于篇幅无法一一介绍。但其遵循一定规律，如下。 Tload_X：将局部变量表数据加载到操作数栈中，T 为类型，如 iload 为加载 int 类型，fload 加载 float 类型。X 为局部变量表槽位索引 Tstore_X：将操作数栈数据出栈，存入局部变量表。T、X 和上文含义一致 Tconst_X：将 T 类型常量 X 压入操作数栈 Tmul：将操作数栈的两个 T 类型常量相乘，结果放入操作数栈。类似的有除法 Tdiv、加法 Tadd 等 i2b：int 类型转换为 byte 数据，类似指令有 i2c、f2i 等 new：对象创建指令 ifeq：分支控制指令，类似指令有 iflt、ifnull、goto 等 invokevirtual：方法调用指令，类似指令有 invokespecial、invokestatic 等 monitorenter：同步指令，有加锁操作时会添加此指令，对应 monitorexit 代表退出同步 更加详细的指令介绍，请参考 官方文档。 总结 本次我们了解了 JVM 运行时区域划分，指令集运行时所依赖的局部变量表和操作数栈等结构，和指令集的类型和操作影响。 指令集中包含了锁操作对应的 monitorenter、monitorexit 指令，和方法调用对应的 invokevirtual 等指令。这些指令和 JVM 实现线程安全和方法的动态连接密切关联。线程安全在我们日常开发中至关重要。方法的继承和重写又是面向对象语言的重要特征。所以 在 JVM 层面，这些都是如何实现的呢？我们下次有时间再聊。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Java/浅谈 JVM 4：类加载机制.html":{"url":"Java/浅谈 JVM 4：类加载机制.html","title":"浅谈 JVM 4：类加载机制","keywords":"","body":" 前文中我们了解了如何阅读字节码和字节码执行引擎中的运行时栈帧结构，字节码执行引擎中的方法调用等内容还未涉及。Java 中多态的特性离不开 JVM 的动态绑定，动态绑定技术是方法动态调用的关键。而如果要介绍方法调用机制，需要先了解字节码在 JVM 中从加载到卸载的生命周期过程。 字节码在 JVM 中从加载到卸载，经历了以下过程。 我们目前掌握了如何阅读外部 class 字节码的结构，和运行时的部分内容。前者属于 “加载” 之前的内容，后者属于 “使用” 阶段。本次我们就来看看从加载到使用之前的这个过程，这就是 JVM 的类加载机制。 外部字节码的输入有多种方式，比如本地 class 文件、网络字节流、程序生成的字节码内容等。 Java 虚拟机将外部的 class 字节码加载到内存中，需要经过加载、链接、初始化三个阶段。 在了解类加载机制之前，我们先来简单回顾下 JVM 逻辑区域的划分。包括 5 部分： 方法区 Java 堆 程序计数器 Java 栈 本地方法栈 加载 加载阶段主要负责读取外部的字节流，将字节流的存储结构转化为运行时数据结构，存储在方法区中。同时在 Java 堆中创建对应类的 java.lang.Class 对象，作为方法区数据的访问入口。此时方法区中的运行时数据结构由虚拟机各自实现。 除了数组类字节流由虚拟机直接生成之外，其他类的加载主要由 ClassLoader 完成。ClassLoader 有启动类加载器、扩展类加载器、应用类加载器，其结构符合双亲委派模型，是指子类加载器在加载类时需要先交给父类加载器加载，如此层层传递，如果父类不处理则再交给子类处理。 启动类加载器由 C++ 编写，没有 Java 对象。扩展类加载器、应用类加载器等均为 java.lang.ClassLoader 子类，需要由其他类加载器，如启动类加载器，加载进来。 启动类加载器主要负责加载最为基础、重要的类，如 JRE 下 lib 目录中的 jar 包。扩展类加载器负责加载 JRE 下 lib/ext 目录中的通用、扩展类。应用类加载器主要加载应用路径下的类。 双亲委派模型保证了类加载过程的安全性和唯一性，因为任何子类加载器（包括开发者自己实现的类加载器）在加载类之前，都需要先将类上交给父类加载器。一方面这保证了不同属性类的加载功能划分，比如 Object 类总会交给启动类加载器加载，这让无论哪个类加载器加载 Object，该类都能够保证相同和唯一。另一方面，这保证了类加载的安全，开发者无法去伪造诸如 java.lang.Object 等基础类来骗过 JVM，因为内置的 ClassLoader 做了相关安全校验工作。 需要注意的是，如果同一个字节码交给不同的类加载实例加载，会得到两个不同的类。 Java 9 模块化的支持对 ClassLoader 做了些许修改，在此不再详述。 链接 链接阶段又分为验证、准备、解析三个阶段。 验证阶段 验证阶段主要负责验证上一步加载进来的字节码是否符合规范，保证不会危害 JVM 的安全。这一步是程序安全的重要保障，此阶段的工作也在整个类加载过程中占有相当的比重，主要包括字节码格式、语法、语义的验证工作。 准备阶段 准备阶段主要负责为类中的静态字段分配内存，并初始化为零值。此时仅会对类变量分配内存，在 JDK 8 及之后，类变量内存会在 Class 对象所处的 Java 堆中进行分配。实例变量的内存分配要等到对象实例化时。 解析阶段 解析阶段是将常量池内的符号引用转换为直接引用的过程。 在前文我们学习阅读字节码时，常量池的常量使用索引表示，常量间的引用关系、方法字节码对变量的获取等操作都是通过引用索引来完成，这些索引称为符号引用。符号引用只是表达变量间的逻辑引用关系，而实际运行时变量、方法所处的内存位置都不是固定的，所以在运行字节码前，需要对这些符号引用进行解析成指向目标的指针、偏移或句柄才行，这和运行时具体的内存布局有关。 当然，解析阶段并未完成所有符号引用的解析过程，对于类或接口、字段、类方法、接口方法的解析可以在此阶段完成。但是对于方法类型、方法句柄和调用点限定符的解析则和动态语言的特性支持密切相关，并不会在此阶段完成。这是因为方法的调用具体对应哪个方法在此时还并未确定，要等到真正执行时才能确定。 初始化 初始化阶段是虚拟机开始执行应用程序代码的开始，是执行类构造器 方法的过程。该方法由 Javac 编译时，通过收集类变量赋值语句和 static 代码块合并产生。 以如下 Java 代码及其对应 字节码为例，可以发现类构造器只会处理类变量和静态代码块中内容，而忽略实例变量。 // java private static int a = 100; static { a = 1000; } private int mThisIsInt = 1024; // bytecode bipush 100 putstatic #28 sipush 1000 putstatic #28 return 在此我们可以提一下静态内部类单例模式的实现方式。 public class Singleton { private Singleton() {} private static class Holder { static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return Holder.INSTANCE; } } 内部类 Holder 的初始化时机是该类的静态字段调用之时，此时触发 方法的调用，进而创建单例对象。JVM 调用该方法时会加锁处理，保证该方法只会调用一次。该特性保证了单例的延迟加载和多线程安全。 总结 本次我们掌握了 JVM 类加载过程的三个阶段：加载、链接、初始化。JVM 在逻辑上分为方法区、Java 堆、程序计数器、Java 栈、本地方法栈。方法区和 Java 堆主要用于存储数据，包括字节码对应数据结构和运行时的对象。其他部分则主要负责运行时方法调用、计算等功能。 在了解了类加载机制、JVM 逻辑区域划分和运行时栈帧及方法字节码执行过程之后，下次有时间我们来聊聊方法间的调用是如何发生的。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Java/浅谈 JVM 5：方法调用机制.html":{"url":"Java/浅谈 JVM 5：方法调用机制.html","title":"浅谈 JVM 5：方法调用机制","keywords":"","body":" 经历了前文中类加载机制、JVM 逻辑区域划分和运行时栈帧及方法字节码执行过程等内容的沉淀之后，我们这次聊聊 JVM 中方法调用是如何发生的，以及静态绑定和动态绑定是什么。 先从一段 Java 代码及其对应字节码看起。 // java private static int methodA() { return 100; } private void methodB() { methodA(); } // methodB's bytecode 0 invokestatic #7 3 pop 4 return Java 代码部分比较简单，在方法 methodB 中调用了 methodA。在 methodB 字节码中，invokestatic #7 部分对应了方法调用功能。我们可以发现，代表了目标方法的 #7 符号包含类名 InvokeDemo、方法名 methodA 以及方法描述符 ()I，即方法参数类型和返回值类型。 由此我们知道，invokestatic 方法调用指令需要类名、方法名、方法描述符（方法参数类型 + 返回值类型）这些信息来识别一个方法。其实除了此指令外，其他方法调用指令也都需要这些信息，无论是重载的方法还是重写的方法。对于重载的方法，JVM 在编译期就可以完成方法符号的解析和识别，所以对于 JVM 来说不存在重载的概念。而对于重写方法的符号解析需要在运行期确定。 类似于重载方法这种在编译期就可以解析的方法，可以称之为静态绑定；对于重写这种在运行时才能解析的方法，可以称之为动态绑定。 方法调用指令 除了 invokestatic 之外，方法调用还有其他几种指令。同样，我们先来看一段示例代码。 public class InvokeDemo { private static int methodA() { return 100; } private void methodB() { methodA(); // invokestatic } private void methodC() { methodB(); // invokevirtual } interface IMethod { void methodD(); } class MethodImpl implements IMethod { @Override public void methodD() { } } private void methodE() { IMethod iMethod = new MethodImpl(); // invokespecial iMethod.methodD(); // invokeinterface } private void methodF() { new Thread( () -> {} // invokedynamic ); } } 从上述代码可以看出，方法调用指令包括： invokestatic：静态方法的调用； invokespecial：构造器、私有实例等方法的调用； invokevirtual：非私有实例方法的调用； invokeinterface：接口方法的调用。 invokedynamic：lambda 表达式等调用。 按照绑定类型分类如下： 静态绑定：invokestatic、invokespecial 动态绑定：invokevirtual、invokeinterface 其中 invokedynamic 指令较为特殊，在此先不谈及。 对于 invokevirtual 和 invokeinterface，大部分情况为动态绑定。但如果方法能够唯一确定，比如被 final 修饰，就可以使用静态绑定直接解析。 方法调用机制 方法符号解析 根据上文我们知道，对一个方法的定位需要类名、方法名、方法描述符（方法参数类型 + 返回值类型）信息。以一个类方法的方法定位为例，其过程如下： 在调用类中，根据方法名和描述符查找方法； 未找到时，递归查找它的父类； 仍未找到时，在其接口中查找。 经过以上过程，方法的符号引用被解析为实际引用。对于静态绑定，实际引用为指向方法的的指针；对于动态绑定，实际引用为方法表的索引。 方法定位与方法表 我们以 invokevirtual 和 invokeinterface 两个指令为例，谈谈动态绑定方法的调用。 JVM 采用使用空间换取时间的方式来实现动态绑定，为每个类生成对应方法表来定位目标方法。方法表根据指令分为 invokevirtual 的虚方法表 vtable 和 invokeinterface 的接口方法表 itable。其中的每个元素指向当前类或祖先类的方法。 方法表的特征要求如下： 跟 Java 的继承特征一致，子类方法表包含父类方法表的所有方法； 子类方法的索引和父类对应方法的索引一致。 方法调用 那么，动态绑定方法的调用过程如下： Java 栈中调用对应指令，如 invokestatic #7 ； 找到方法的调用者——Java 堆中的类； 访问该类对应的方法表； 找到方法的地址，调用方法。 除此之外，JVM 还使用了内联缓存、方法内联的技术来优化动态绑定方法的调用。内联缓存就是将动态绑定方法解析后的类型和目标方法缓存起来，下一次碰到相同类型直接使用。仍然是空间换时间的策略。 总结 至此，我们可以在脑中构建出 JVM 运行字节码的大致流程。从外部的字节码结构和解读方法，到虚拟机加载字节码流的过程，然后是虚拟机逻辑区域划分和每部分的功能，以及 Java 栈中的计算过程，最后是具体方法调用指令的解析、调用机制。 当然，JVM 相关的内容不止这些。比如 Java 堆的内存管理和回收机制、JVM 的启动过程、JNI 调用机制等，我们还未涉及。 另外，当初使用 Java 作为官方语言的 Android，其内部在前期使用的 Dalvik 虚拟机和后来的 ART 虚拟机在结构和运行字节码上又有何不同？当下力推的 Kotlin 在虚拟机的执行上和 Java 有什么不同吗？ 我们有时间再聊。 推荐 工具：leetcode 的 VSCode、IDEA 插件。推荐原因：可以方便的浏览、提交算法题，和谐地在 IDE 中刷题。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Java/浅谈 JVM 6：Android 虚拟机对比.html":{"url":"Java/浅谈 JVM 6：Android 虚拟机对比.html","title":"浅谈 JVM 6：Android 虚拟机对比","keywords":"","body":" Android 开发最初使用 Java 作为主要开发语言，后来由于版权等原因，Google 官方目前推荐使用 Kotlin。但无论是 Java 还是 Kotlin，都是需要编译成字节码，然后经过 Android 特有的优化，运行在 Android 虚拟机中的。JVM 主要为电脑而设计，直接在手机设备上使用会有很多问题，比如耗电等。Android 虚拟机也针对手机设备做了一些优化。 本文来简单对比一下 JVM 和 Android 虚拟机。 虚拟机在类型上分为两种。 系统虚拟机：一个完整的虚拟机，提供了真实硬件的模拟，比如 VirtualBox、VMware 属于此类； 处理虚拟机：通过解析指令的方式来执行程序，主要目标是提供一个平台无关的环境。 JVM vs DVM Java 虚拟机属于第二类，主要提供了平台无关的 Java 代码执行环境，其中一种方式就是通过解析字节码的方式运行。 JVM 工作流程可以主要参考 “浅谈 JVM 4：类加载机制” 一文，在此不再详述。 Android 系统采用 VM 来运行上层程序有两个原因： 安全：应用层代码运行在 VM 中，和系统其他代码完全隔离，能够保证应用和系统的安全； 平台无关：相同的代码可以运行在不同的架构中（ARM，MIPs，x86）。 Android 的虚拟机叫做 Dalvik Virtual Machine（DVM），该虚拟机能够执行 Dalvik EXecutable 字节码，可以使用 dx/d8 工具从 Java 字节码转换而来。转换过程中做了内存、处理速度的优化。相当于从多个 .class 文件编译为 .dex 文件放在 APK 中。 栈 vs 寄存器 根据我们前几篇文章分析，JVM 是基于栈的虚拟机，而 DVM 基于寄存器。基于寄存器的虚拟机使用更少的指令集、更少的代码和更少的内存操作，所以在性能上也有更好的表现。 这两者的差异意味着 Android 虚拟机的指令集中更多的是类似于汇编语言中的 move 等指令，而非 JVM 的 push、pop。 DVM vs ART ART 用于替代早期的 DVM，ART 为了兼容以前的程序，同样使用 dex 字节码。但是在安装时会使用 dex2oat 将 dex 字节码转换为 oat 本地码。 除此之外，ART 优化了垃圾回收机制、更快的本地方法调用、更加省电、应用程序启动更快、更好的运行时性能等。 你可以通过下图查看不同虚拟机的 apk 在安装后文件结构的差异。 JIT vs AOT Just In Time（JIT）在 JVM 有对应机制，在 Android 2.2 添加到虚拟机中。这是一种运行时优化热点代码的机制，即当虚拟机发现某段代码运行次数够多时，会将该段代码编译为机器码，下次执行该该代码时，直接运行机器码即可。这优化了程序运行性能。 Ahead of Time（AOT）是在安装应用时，将字节码编译为本地机器码。这减少了运行时编译的时间，提高了运行性能。但增大了安装耗时和存储空间占用。 总结 我们这次简单对比了下两个虚拟机的异同。掌握了本系列文章中涉及的知识之后，其实就已经具备了自己写一个虚拟机的理论知识。如何手写一个虚拟机？我们有机会聊聊。 拓展资料 Android 运行时 dex 文件格式 Dalvik 指令集 Virtual Machine in Android: Everything you need to know Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Linux 那些事儿/apt 和 apt-get 有什么不同之处？.html":{"url":"Linux 那些事儿/apt 和 apt-get 有什么不同之处？.html","title":"apt 和 apt-get 有什么不同之处？","keywords":"","body":"apt 和 apt-get 有什么不同之处？ [TOC] 在使用 Ubuntu 命令行时，我们会碰到 apt 和 apt-get 命令，这两个命令有什么不同呢？ apt-get 命令 apt-get 命令可以让我们安装、更新、移除软件包。apt-get 是一个我们可以和 APT（Advanced Package Tool）包管理系统的命令行工具。除此之外，还有 apt-cache、apt-config 命令。 apt 命令 apt 则是最新添加的一个命令，和 apt-get 的不同点主要有： apt 包含了 apt-get 和 apt-cache 的功能 apt 有更多的输出和改进后的设计 同样的功能，apt 的命令语法有不同之处 apt 中有两个独特的新功能 1. apt 包含了 apt-get 和 apt-cache 的功能 在 Ubuntu 16.05 之前，开发是通过 apt-get、apt-cache、apt-config 命令来和 APT 包管理系统交互的。这些工具提供了很多功能，但是一般来说开发者并没有使用他们提供的所有功能。 因此，Linux 想要创建一个更简单的工具——只具备基本功能即可。这一工具便是 apt，伴随 Ubuntu 16.05 和 Debian 8 发布。 其主要目标是去合并最多使用的 apt-get 和 apt-cache 命令的功能到一个命令下：apt。 2. apt 有更多的输出和改进后的设计 apt update 命令增加了展示有多少包可以升级的输出，如下图： 然后你可以使用 apt list —upgradable 命令查看可升级的包具体有哪些。这里在设计上作了改进：对于包名做了颜色特殊处理，如下图： 另外，apt 命令在升级包的时候添加了进度条，让升级进度一目了然。 3. 同样的功能，apt 的命令语法有不同之处 apt 在命令上做了一些调整，和之前的 apt-get、apt-cache 命令的用法有所不同，见下表。 功能 之前的命令 apt 命令 更新包仓库 apt-get update apt update 升级包 apt-get upgrade apt upgrade 升级包且移除不必要的依赖 apt-get dist-upgrade apt full-upgrade 安装包 apt-get install [package_name] apt install [package_name] 移除包 apt-get remove [package_name] apt-remove [package_name] 通过配置移除包 apt-get purge [package_name] apt purge [package_name] 移除不必要的依赖 apt-get autoremove apt autoremove 搜索包 apt-get search [package_name] apt-get search [package_name] 展示包信息 apt-cache show [package_name] apt show [package_name] 展示激活的包源 apt-cache policy apt policy 展示已安装包和可用版本 apt-cache policy [package_name] apt policy [package_name] 4. apt 中有两个独特的新功能 apt 中添加了两个新的功能： 编辑包源列表 apt edit-sources 列出标准包 apt list 什么时候使用 apt 而不是 apt-get？ 大多数 Linux 用户都建议能用 apt 就用 apt，而不是 apt-get。不仅仅是因为 apt 更容易敲出来和容易记忆，也是因为 apt 执行更快一些。 不管怎么说，使用哪个命令只是习惯问题，尝试去习惯 apt 命令吧。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Linux 那些事儿/Linux 命令行 Tricks.html":{"url":"Linux 那些事儿/Linux 命令行 Tricks.html","title":"Linux 命令行 Tricks","keywords":"","body":" 最近老弟说要上手 Linux，所以借此机会简单介绍几个 Linux 的命令。用 Linux 大多数时候，简单来说，我们是指的终端命令行的操作。接下来我就说几个比较便捷、简单、有趣的操作。 本文只针对入门级，老鸟请绕道。 1. cd - 我们都知道 cd [dir] 是进入某个目录，cd .. 是返回上一层目录。但是当我们进入了很深层级的目录的时候，想返回之前目录就可能执行多次 cd ..，此时我们可以使用 cd - 命令直接返回上一次所在的目录。 2. cd 在任何目录下，执行 cd 都可以返回到 home 目录。等价于 cd ~/。 3. !! 当我们执行一条很长的命令，但是执行结果表示需要更高的权限——root——时，这个时候是不是很沮丧？ 有了 !! 命令，此时直接输入 sudo !! 即可。!! 会自动被上次输入的命令所替代。 4. 命令输入历史搜索 我们都知道 Ctrl + P 和 Ctrl + N 可以上下切换之前、之后输入的命令。但是当我们输入一个命令是很久之前，这个方法就不够有效了。 此时可以键入 Ctrl + R，然后输入你印象中的命令关键字，相关的命令就会出现了。这样是不是更加高效呢？ 5. 复制、粘贴 在 Windows 上，我们通常用 Ctrl + C 和 Ctrl + V 进行内容的复制和粘贴，但是在 Linux 终端中我们发现这个行不通了。因为 Ctrl + C 被用来终止当前运行程序。那如何在 Linux 终端进行复制和粘贴呢？ 答案是 Ctrl + Shift + C 和 Ctrl + Shfit + V。 6. nohup 当我们执行一个耗时的命令时，此时该命令正在占用我们的终端。我们如果不小心把命令行关掉，该命令的执行也就半途而废。哪有什么办法可以解决这个问题呢？ 那就是 nohup。在你要执行的命令前添加 nohup，该命令就会在后台执行，其输出结果会写入到 nohup.out 文件中。 7. screenfetch screenfetch 可以让我们在命令行查看当前系统信息，你可能需要执行以下命令安装该工具。 sudo apt install screenfetch 8. cowsay 如果写代码写累了，你可以和你的牛🐮️说说话。 # install sudo apt install cowsay # talk echo \"hi\" | cowsay echo “hi” | cowsay 这里用到了“管道”，一个强大的功能，感兴趣的话去探索一下吧。 资源 内容由浅入深，根据自己情况按需阅读。 Linux 教程_w3cschool 鸟哥的 Linux 私房菜 《Linux 程序设计》 《UNIX 环境高级编程》 《深入 Linux 内核架构》 参考资料 15 Essential Linux Command Line Tips and Tricks | by Michael Krasnov | Better Programming | Medium Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"Linux 那些事儿/Linux 终端操作入门.html":{"url":"Linux 那些事儿/Linux 终端操作入门.html","title":"Linux 终端操作入门","keywords":"","body":" 和 Windows 平易近人的视窗操作不同，Linux 更多的是终端操作。服务器中有 70% 以上在运行 Linux 操作系统，所以 Linux 更多的是为服务器或者说开发者服务，尽管 Ubuntu 的桌面软件已经做得很不错。所以本文主要介绍如何入手通过终端操作 Linux。 万能钥匙 首先，介绍一个核心命令 man 命令。通过这个命令你可以查看任何命令的使用手册，man 即为 manual 的简写。比如 man ls 可以查看 ls 命令的使用方法。当你对一个命令有任何疑惑时，即可通过此命令来获得帮助。你甚至可以通过 man man 来查看 man 命令如何使用。 除了 man 命令之外，你一般还可以通过 command -h 的方式来查看一个命令的使用方法，这里是使用命令的内置参数 -h 来查看其使用方式。 有时候我们会苦恼于上述两种方式得到冗长的文档介绍。这时可以使用更简洁的使用方法查看命令 tldr。tldr 即 too long, don't read 之意。它提供了简要的命令说明，并且例举了常用的命令使用方式，如果你不需要查看命令的具体细节，只需要知道命令的直接用法，用 tldr 就好。点击跳转 GitHub。 上述三种方式可以帮助我们查看任何命令的使用方法，可以说是一把万能钥匙。 用户管理 不像 Windows 那样的登录界面，Linux 启动之后等待你的如下图所示，一个让你输入用户名密码的文字窗口。你想进行的一切操作，只能通过命令行的方式来处理。 就像 Windows 中的最高权限用户 Administrator 一样，Linux 叫 root 拥有系统的最高权限。 进入系统之后，你可以通过 passwd 命令来修改密码。可以通过 useradd 来创建新的用户。Linux 中有用户和用户组的概念。如果 useradd 没有指定用户组的话，系统会给你创建一个用户同名的组。也可以通过 -g 参数的方式指定用户组。 Linux 的设计理念是一切皆文件。所以上述两个命令执行后，所对应的是 /etc/passwd 和 /etc/group 两个文件的改动。可以使用 cat 命令查看两个文件的内容。 文件管理 文件系统有文件夹和文件的概念，文件夹可以包括子文件夹和文件。这样就形成了一个树形结构来管理文件之间的层级关系。 通过 cd 我们可以修改当前的所在目录，cd 即 change directory 之意。cd 后可以跟相对路径和绝对路径。另外 cd .. 可以返回上一层目录，而无需输入冗余的路径信息。 ls 查看当前文件夹下的目录结构，-l 选项为以列表的方式查看，同时会列出相关的文件信息。-a 选项指查看所有文件，包含隐藏文件—— . 开头的文件。 另外可以通过 chown 改变文件的所属用户，即可以对其进行操作的用户。chgrp 改变文件的所属组。 mkdir 可以创建目录，rmdir 删除目录。rm 配合对应参数则可以删除目录和文件。 cp 可以复制文件，mv 为移动文件或者修改文件名称。 cat 可以查看文件内容，但是它会输出所有文件内容，当文件内容过长时，可以使用管道接入其他命令做出优化。比如 head 命令，cat file | head -5 代表查看 file 的内容，通过管道传递给 head 命令，然后 head 命令会列出前 5 行的内容。此类辅助性命令还包括 tail、more、less。 vim 可以说是文字窗口下，文本编辑的瑞士军刀。使用它可以像 IDE 那样写代码。可以先掌握其几种模式和简单的文件编辑、保存操作。因为其学习曲线比较陡峭，所以需要慢慢掌握。安装 vim 之后，可以安装一个叫做 vimtutor 的教程软件，把该教程学完，对于 vim 的可以形成一个整体的认识并掌握基础操作。 软件安装 下载安装包后安装 以 Ubuntu 为例，它是使用 deb 作为安装包。相关命令如下： // 安装软件 dpkg -i jdk.deb // 在已安装软件中查找 dpkg -l | grep jdk // 删除软件 dpkg -r jdk 其中查找软件命令中同样用到了管道，其含义是把所有已安装的软件信息传递给 grep，grep 是一个过滤、筛选的命令，查找带有 jdk 字符的内容。 CentOS 也具备这些能力，只不过其命令更换为 rpm，具体细节可以自行探索。 软件管家安装软件 就像 Windows 上有腾讯软件管家整合了大多数软件，可供下载安装一样。Linux 也提供了对应的命令工具。 仍然以 Ubuntu 为例，使用软件管家工具相关操作如下： // 安装软件 apt install jdk // 搜索可供安装的软件 apt-cache search jdk // 删除软件 apt-get purge jdk 软件管家从网上下载软件需要有对应的服务器提供下载服务才行，可以在 /etc/apt/sources.list 里查看相关软件源地址。 CentOS 与之对应的命令工具为 yum。 下载文件配置环境变量 在 shell 中执行一个命令时，它会去环境变量 PATH 配置的目录中查找这个命令，查找到后会运行此程序。 所以安装软件其实是这样一个过程：下载软件并解压；配置环境变量即可。上述两种方式，其实是工具帮我们屏蔽了此过程。 我们完全可以手动进行此操作。 首先通过 wget 或者 curl 下载工具下载软件压缩包，然后通过 tar 或者 unzip 进行解压。解压之后，我们执行 export PATH=/your/directory:$PATH 命令即可更新环境变量，然后在终端执行新安装的命令即可。 运行程序 我们输入一个命令其实就是在运行一个程序。但是我们有时候碰到一个程序运行许久没有结束，但是我们想要结束进行怎么办？可以使用 Ctrl + c 即可终端程序的执行。 我们还可以通过 nohup command & 的方式将一个程序放在后台运行。后台运行的程序我们就需要配合 ps 命令查看，通过 kill 命令杀掉某个程序。 关机和重启 最后，使用 shutdown -h now 可以马上关机，当然你可以修改参数进行定时关机。使用 reboot 命令进行重启。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"macOS/黑苹果安装与踩坑记.html":{"url":"macOS/黑苹果安装与踩坑记.html","title":"黑苹果安装与踩坑记","keywords":"","body":"黑苹果安装与踩坑记 根据我自己的经历，对于一个开发者来讲，macOS + Alfred + terminal + Dash ... 等软件的使用体验比Windows好很多。同时受限于MacPro的价格，所以最近萌生了在自配电脑上安装黑苹果的想法，MacPro还是工作之后再入手。本文可能涉及侵权等问题，所以本文只用于个人知识学习，不授权于任何人用于商业用途。 本文包含以下内容： 我的电脑配置与macOS High Sierra 制作Mac系统安装U盘 安装macOS 安装驱动 给要安装系统的硬盘添加启动项 工具包 一、我的电脑配置与macOS High Sierra CPU：Intel i5 7500（自带 Intel HD Graphic 630 集显） 显卡：七彩虹/技嘉 GeForce GTX 1050 Ti（Pascal系列） 主板：技嘉（GIGABYTE） B250-WIND （M-ATX紧凑型） 网卡：瑞昱RTL8168/8111/8112 Gigabit EthernetController 声卡：瑞昱ALC887 高保真音频 内存：金士顿骇客神条 Fury系列 DDR4 2133频 8G 硬盘：金士顿固态硬盘 M.2接口 128GB 散热器：采融B41（风冷） 电源：蓝暴炫动二代400W 我已验证安装的系统有macOS High Sierra10.13.3（17D47） 和 10.13.2（17C88）版本，两者安装方法完全一致，我也都安装成功。但是由于10.13.3（17D47）所对应的NVIDIA Web Driver有bug，安装后无法驱动显卡。所以目前建议安装10.13.2（17C88）版本，同时安装对应的NVIDIA Web Driver版本即可。等新版本NVIDIA Web Driver的bug修复后，再进行安装。 以下说的是macOS High Sierra 10.13.2（17C88版本）的安装过程。此教程只保证能够作用于以上的电脑配置。 二、制作Mac系统安装U盘 （此方法需要一台Mac） 此U盘的制作方法需要一台装有macOS系统的电脑或虚拟机，当然也有用Windows制作安装U盘的方法，可以参考博客 点击查看，但此教程中的方法未亲自验证。 准备： 装有macOS系统的电脑、8G及以上U盘（最好是USB 2.0）、macOS High Sierra 10.13.2系统。 制作过程： 打开App Store，下载macOS High Sierra系统。目前最新的版本是10.13.3，10.13.2系统版本可以从这里下载：点击下载，密码: t3du。下载后解压，将其中的“安装 macOS High Sierra.app”文件移到“/Applications”文件夹下（就是“应用程序”文件夹） 使用UniBeast工具安装，点击下载，需要注册登录，不要怕麻烦，https://www.tonymacx86.com 是一个很棒的黑苹果站点，然后按以下步骤进行 使用系统自带的“磁盘工具”格式化U盘为图中格式和GUID分区。最新的系统似乎不会显示GUID分区，可以通过终端命令来查看：diskutil list。找到U盘名字的部分，包含EFI分区即可，注意EFI分区要大于200M，效果如图所示 UniBeast工具中，BootLoader Configuration 选项选择 “UEFI Boot Mode” Graphics Configuration 不要勾选内容（这个对应于显卡参数，1050Ti显卡一定不要勾选） 安装即可完成macOS High Sierra启动U盘的制作 修改BIOS设置，我的电脑配置所对应的BIOS设置项目如下： 电脑启动时按“DEL”键进入BIOS设置 在“储存并离开”面板中，选择 加载默认配置 在“芯片组” 面板中，取消支持 VT-d 在“BIOS功能”面板中，设置 Win8 / 10系统 选项为 “其他系统” 在“集成外设/SuperIO配置”中，取消支持 IO Serial Port 在“集成外设/USB程序”中，设置支持 XHCI Handoff， 此步骤不设置，会导致系统加载一点就不动了 注： 写U盘的时候，UniBeast在加载一点之后，进度条会不动，这是在写系统到U盘，耐心等待即可 UniBeast 8.1 对应的系统系列是 macOS High Sierra，适合10.13.2版本安装 参考内容： unibeast-install-macos-high-sierra-on-any-supported-intel-based-pc 简书博客 三、安装macOS 准备 要把想装macOS High Sierra系统的硬盘格式化为 GPT + EFI 分区格式，可以在Windows系统中用DiskGenius工具操作。 安装步骤 插入U盘，F12 选择从U盘 clover启动 系统进行从U盘的第一次加载 加载完成之后，先选择语言，然后使用“磁盘工具”格式化要安装macOS的硬盘为APFS格式，命名为“Mac”。然后安装系统。安装之后重启继续安装 从U盘clover启动，在Clover页面选择其中的“install High Sierra from MAC”。会多次重启，选择相同选项启动即可 安装完成 注：安装时不要连接网络，也不要登录iCloud，否则会出问题 安装的时候可能会遇到的问题及其解决 系统第一次加载一点就卡住不动 解决：严格按照第二步中“我的电脑对应的BIOS设置”来操作BIOS即可。 第一次加载到大概3/5的地方，开始转菊花 解决：在UniBeast制作启动U盘时，不能选择 Inject NVDIA 选项（此选项用于驱动老型号显卡——GeForce 630及以下），因为这会修改启动U盘的EFI/Clover/Config.plist文件中的Graphic子标签：Intel 设置为false，NVDIA设置为true。这可能是因为老版本驱动不支持1050Ti显卡 四、安装驱动 安装驱动过程 选择U盘启动，之后选择“Boot from MAC”。如果硬盘已经加入了clover引导项，也可以从硬盘clover启动Mac 进入系统之后，使用MultiBeast安装驱动，各个选项如下（安装驱动时不要挂载EFI分区，否则会导致安装FakeSMC失败） QuickStart：UEFI Boot Mode Drivers： Audio：VoodooHDA v2.8.9 Disk：3rd Party SATA & 3rd Party eSATA & Intel Generic AHCI SATA Misc：默认 FakeSMC不动 Network：IntelMausiEthernet v2.3.0 Booloaders：Clover UEFI Boot Mode + Emulated NVRAM Customize Graphics Configuration：Intel HD 6xx & Intel Graphics Fixup SSDT Options：Sandy Bridge Core i5 System Definitions：iMac 14，2 Build中选择Mac，点击Install进行安装 重启系统 成功启动后，把U盘中的启动项 - EFI文件夹 拷贝到硬盘的 EFI分区中。使用硬盘启动系统，正常启动即可。这是作为U盘Clover启动项的备份，为了测试显卡驱动，需修改config.plist文件，以此来防止修改错误导致进不了系统 安装 NVIDIA Web Driver，安装很简单，可以参考教程：点击查看，安装出现问题及解答：点击查看，软件下载：点击下载 删除config.plist中的 nv_disable=1，同时编辑config.plist文件的如下部分，重启即可 SystemParameters InjectKexts YES InjectSystemID NvidiaWeb 安装驱动碰到的问题 问题：MultiBeast安装到FakeSMC失败解决：使用MultiBeast安装驱动时，不要挂载U盘的EFI 注： 第二步和第五步的软件可同时进行安装 不要修改Graphics/Inject/NVidia标签为true，这样会在重启后，系统加载到一半时转菊花 nvda_drv是以前驱动Nvidia显卡的方法，不支持Sierra。NvidiaWeb是Sierra中的新方法 在macOS High Sierra中，注意要取消nv_disable，设置NvidiaWeb 五、给要安装系统的硬盘添加启动项 要求 要安装黑苹果系统的硬盘是 GPT + EFI格式分区，可以在Windows系统中用DiskGenius工具操作，安装懒人版系统似乎不用必须是此分区格式。 过程 在安装好的macOS High Sierra系统中操作：把启动U盘EFI分区下的 EFI文件夹 直接复制到硬盘的EFI分区即可。此过程主要目的是不再使用U盘作为引导项启动macOS，摆脱对U盘依赖。而是直接使用硬盘的clover引导启动系统。所以此步骤较为灵活，可以选择任何合适的时机进行操作。 也可参考此教程的方法给要安装系统的硬盘添加“clover启动项”：点击查看教程 ，见教程第三步“Clover 引导安装”。 六、工具包 所有工具见百度云盘，点击下载，密码: im9u 最后晒一下我的Hackintosh。 祝好运！ Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"TDD/浅谈测试驱动开发.html":{"url":"TDD/浅谈测试驱动开发.html","title":"浅谈测试驱动开发","keywords":"","body":" 我们经常会碰到在项目迭代的中后期，代码变得臃肿、混乱的情况。后期参与到项目中的开发者，阅读、修改代码将成为一个让人头疼的大问题，也是团队开发效率的瓶颈之一。如何持续保证代码质量，是每个开发团队和开发者需要面临和解决的一个问题。 1. 苹果会腐烂，代码也会 我们在编写代码前，都会进行良好的设计。但是随着时间的流逝，人们不断修改代码，使得现有代码逐渐偏离初期的设计，代码结构逐渐崩塌，代码慢慢腐烂。 “在代码写好之后改进它的设计”听起来有些奇怪，这是不是因为自己初期代码设计有问题呢？一辆汽车我们需要时常进行保养，代码也是如此。否则面对丑陋的代码时，我们就会落入这样一种情况：如果修改，担心破坏了原有的功能，引发新的问题；如果不修改，现有的代码实在难以阅读，难以修改，有代码洁癖的开发者还会觉得难受。 任何代码的修改都需要一个验证环节，来保证修改的正确性。也就是说，代码修改后，开发者需要反馈。 2. 增加反馈 无论是增加新特性，还是修复 bug，都涉及到代码的修改。一般来说，我们修改代码后，对特性的验证是通过测试同学运行自动化测试脚本或者手动验证来进行的。换句话说，我们修改代码，然后祈祷修改有效，而且不会引发新的 bug。最后等待上帝给到我们测试通过的反馈。有时候这个等待过程会比较漫长。 没有编写相应测试的代码都是遗留代码。 ——《修改代码的艺术》 另外一种反馈周期短上许多的方法是给代码增加单元测试。单元测试有以下优点： 测试单元更小，一般来说是一个函数或类； 运行速度快，好的测试在毫秒级别； 能够帮助我们定位问题； 单元测试是对应代码的“需求文档”。 3. 测试驱动开发 测试驱动开发（Test-Driven Development）将测试的重要性推到了极致。在其开发流程中，开发者首先要做的就是编写一个失败的测试。TDD 核心开发流程为：红-绿-重构。如下图： 当开发者拿到一个需求时，首先确定需求模块对外接口，然后进行任务分解，将工作划分为不同功能点，最后针对每个功能点进入红-绿-重构的循环： 红：编写一个失败的测试； 绿：编写功能代码让测试通过； 重构：消除代码坏味道，优化代码，然后运行测试，检验功能是否完整。 4. TDD 的优点 测试驱动开发最直接的收益就是可以提高开发者的效能。 在开发一个功能模块时，比较耗时的部分有：设计、编码、发现问题、定位问题和修复问题。然而后三个部分占用了一般的工作时间。如果可以优化这些耗时，我们的开发效能将大大提高。 TDD 便可以做到。单元级别的测试能够保证我们在极小的粒度上发现和定位问题，运行所有单元测试，便可以找到出问题的部分。而针对函数级别的问题，我们也可以十分迅速的进行修复。 如果你想要成为一个高效的程序员，掌握 TDD 便是必要的。不得不说，当我了解测试驱动开发，走入 TDD 的大门时，便成为了它的拥趸者。 总结 本文主要介绍了代码会随着时间流逝腐烂，需要通过时常的修改代码来保证代码质量。这时需要通过增加测试的来验证修改后功能的完整。最后了解了测试驱动开发这一提高效能的研发流程。然而对于 TDD 的掌握，其中重要的一部分便是实践。以后有时间我们会介绍一下重构相关的方法和如何不断地让代码保持良好。 参考资料 《测试驱动开发》 《重构》 《修改代码的艺术》 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:31 "},"操作系统/谈谈进程间通信.html":{"url":"操作系统/谈谈进程间通信.html","title":"谈谈进程间通信","keywords":"","body":"谈谈进程间通信 我们在一个操作系统之上可以同时登录多个用户使用计算机，同一个用户可以一边使用音乐软件听歌，一边使用 IDE 写代码。这都离不开操作系统中的进程。 进程和线程 进程是操作系统中最核心的概念，是正在运行程序的一种抽象。音乐软件、IDE 都对应一个或多个进程。不管是 UNIX 还是 Windows，进程各自拥有不同的地址空间。然而进程间不免有共享数据的需要，这也是进程间通信机制的用武之地。 除了多进程模型，每个进程中建立了多线程的机制。线程可以类似于进程进行并行运行，不同之处是线程间共享内存空间；线程也更加轻量，创建和销毁成本更低；单个应用中可以通过多线程实现一些并行运行，防止 I/O 等操作耗时阻塞程序运行的情况。 进程间通信 进程经常需要和其他进程进行通信。而进程的内存空间私有、进程并发运行的特性，进程间通信要克服以下三个问题： 进程间如何传递数据？ 多个进程在进行关键活动时如何互斥？ 生产者生产数据和消费者消费数据的顺序如何保证？ 对于线程来说，线程间共享一块内存空间，所以线程间传递数据的问题迎刃而解。而问题 2、3 是线程间通信仍然需要解决的。进程间通信机制也可以拥有线程间通信。 进程间如何传递数据？ 对于第一个问题，我们知道数据是在硬盘、内存和网络中存储传输。所以我们可以建立一个公共数据区域，进程通过写入和读取该区域来实现进程间通信；或者直接通过网络通信，传输数据。进程间通信都包含如下情况： 共享内存 共享文件 网络传输 对于共享内存，Linux 的管道、Android 的 Parcelable 序列化都是在内存中储存。 对于共享文件，通过文件读写数据、Java 的 Serializable 序列化是在磁盘中存储数据。 对于 Linux 的套接字 Socket 通信则是通过网络传输进行进程间操作。 多个进程在进行关键活动时如何互斥和保证顺序？ 进程间通信存在数据写入方和数据读取方，即生产者和消费者。如果多个生产者进程需要生产数据时，我们需要保证同一时间只有一个生产者在进行写入操作，否则就会出现数据出错的问题。这一操作的限制我们称之为互斥，进程中写入数据部分的代码区域我们称之为临界区。 对于保证多个进程在关键活动时的互斥，我们可以采取以下方式。 1. 屏蔽中断 在进程进入临界区，进行关键操作之后，我们屏蔽所有中断。CPU 在发生时钟中断或其他中断时才会切换进程，这也保证了进程间的互斥。 然而，屏蔽中断后其他进程将处于阻塞状态，如果当前进程操作耗时较长，严重时会出现操作系统终止的情况。同时屏蔽中断只在当前 CPU 中起作用，无法在多个 CPU 时起到进程互斥的效果。 2. 锁变量 我们可以通过共享变量的值，来代表是否已经有进程在操作共享内存区域。但是共享变量也存在进程切换时，对锁变量读取失效的问题。即进程 1 读取共享变量值为 0，因此判断可以进行内存操作；此时 CPU 切换进程 2 开始执行，进程 2 读取的变量值仍为 0，也进入了临界区。此时有两个进程进入了临界区，锁变量实现多进程互斥的计划就泡汤了。 3. 忙等待 解决锁变量的问题我们可以通过循环读取变量值的方式来保证值失效的问题。其代码如下。 // process 1 while(TRUE) { while (turn != 0); enter_region(); turn = 1; leave_region(); } // process 2 while(TRUE) { while (turn != 1); enter_region(); turn = 0; leave_region(); } 忙等待的缺点是循环等待浪费了 CPU 时间，同时在两个不同优先级的进程间通信时，可能出现优先级反转问题。假如低优先级的进程 L 处在临界区时，高优先级进程 H 就绪开始运行，H 进程一直处于忙等待，此时又无法切到低优先级进程 L 中执行让 L 离开临界区，导致通信无法进行。 对此，我们可以使用 sleep、wakeup 操作替换忙等待。即进程 1 在发现内存区域被其他进程占用时，通过系统调用进入阻塞状态；进程 2 在操作完成后唤醒其他进程。其代码如下： int N = 100; int count = 0; // producer while(TRUE) { int item = produce_item(); if (count == N) sleep(); insert_item(item); count = count + 1; if (count == 1) wakeup(cousumer); } // consumer while(TRUE) { if (count == 0) sleep(); int item = remove_item(); count = count - 1; if (count == N - 1) wakeup(producer); consume_item(item); } 4. 信号量 对于上述代码，存在这样一种情况： 消费者 consumer 进程，第一行代码读取 count 值为 0 之后，切换到 producer 进程执行； producer 生产了数据并放入缓冲区，然后调用 wakeup 去唤醒 consumer，但此时 consumer 还未 sleep，所以 wakeup 信号发生丢失； 切回 consumer 进程时，count 此时仍为 0，consumer 进入 sleep 状态； 生产者一直生产，直到缓冲区满，进入睡眠。 此时生产者、消费者进程都处于睡眠状态，原因是 wakeup 信号丢失了。 该问题可以通过新增一个信号量来解决，即 wakeup 信号的数量。把信号量值的读取、更新和睡眠操作作为原子操作，也就是不要在读取信号量之后切换进程，以防止出现上述问题。而防止切换进程的操作可以通过屏蔽中断来保证，由于此时信号量的读取、更新、进程睡眠操作耗时较短，所以不存在之前的问题。另外，对于多个 CPU 的情况，可以通过锁变量 + TSL 机制保证多 CPU 多进程对信号量的互斥。 5. 管程 在 Java 中的线程同步可以使用 synchronized 关键字。经过关键字修饰的代码编译后的字节码会自动增加 monitorenter、monitorexit 指令。 Java 是一种支持管程的语言，开发者无需关心管程的实现，它完全由编译器完成。该指令的实现也结合了锁、信号量、等待和唤醒机制。 总结 本次我们了解了进程间通信的三个问题和可选的解决方法及其缺点。通过共享内存、文件来传输数据，通过锁、信号量等机制保证内存读取的互斥和有序。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"算法与数据结构/算法与数据结构 1：开篇.html":{"url":"算法与数据结构/算法与数据结构 1：开篇.html","title":"算法与数据结构 1：开篇","keywords":"","body":" [TOC] 经历过长久的停滞，码字的念头又跳回到我的大脑。可能是希冀记录一下自己人生，毕竟人这一生如落花似流水；可能是受朋友激发，发现原来身边也有同行者，在写作上不再孤独；可能是主动总结一下生活和技术经验，算是对一段时间内的自己做下整理，就像把信息当作食物放进锅里煮，祈求能够融会贯通，做出一顿美食，以飱读者。好啦，字数凑完，以下进入正文。 本文主要内容： 为什么要学算法与数据结构？ 算法与数据结构有哪些内容？ 下期预告： 如何学习算法与数据结构？ 我们都知道算法和数据结构是计算机技术的基础，但对于要牢牢掌握算法与数据结构我们可能心存疑问。学生可能会问：算法和数据结构学来何用，远不如写点网页、Android 或者 iOS 来的直观。社会人可能会问：写了几万行代码，没用过算法和数据结构，学这干啥？确实如此，理论和实践比起来总是显得更加遥远。下面我来结合算法与数据结构在计算机技术知识中所处的位置和实际情况说一下为什么。 为什么要学算法与数据结构？ 1. 它是内功，它是地基 如果把计算机各种技术比作武术，那算法与数据结构、操作系统、编译原理、计算机网络等等均属于内功，而像各种工具如 IDE、Git 等等的使用、各种语言 API 属于外功。 张无忌就是学了《九阳神功》才得以拥有快速学习掌握其他招数的能力，学乾坤大挪移之速度把美丽的小昭都看傻眼了。 建盖楼房时，要想盖的更高，地基也必须要打的更深才行。这和你想成为技术专家，必须掌握牢靠的基础知识是一个道理。 你是否在担心自己 35 岁失业？你是否在担心技术更新太快来不及学习？熟练掌握计算机基础知识可以说是此问题的命门所在。树木生长枝桠不可能凭空长出来，都必须依靠上一个树枝才能结出新枝。科技、文化亦是如此。不要惧怕新技术的浪潮把自己拍在沙滩上，因为新技术也是从旧技术生长而来，其核心不会发生太大变化，只要你不是浮在表面，而是掌握了内在的原理，那你完全可以用很快的速度学习掌握新技术。如此，那还怕啥？ 2. 它有用，它有大用 香农的信息论奠定了计算机的基础。当今互联网时代可谓信息弥漫，电磁波载着各个终端的数据来回穿梭，我们确实活在信息的世界。在这个世界中，信息处理必不可少，而做这个事情就要用到算法。更何况，大数据时代对算法的高效要求更甚。 这也是一个移动时代，手机就像我们植入的硬件，已经无法离开。马斯克的生物科技公司 Neuralink 在开发一种可以植入脑中的设备，和这种能够生理上植入大脑的设备相比，手机已经植入我们的脑中，只不过是精神上的。我们的生活已经大大依赖于此，就像领土对于国家一样，手机对于我们来说是不可分割的一部分。 说回我们日常用手机完成生活的很多事情，比如我们要点外卖，如何匹配到离店家最近的外卖员，又如何确定他可以在限定时间内送完手上的订单？比如你要打车回家，如何选择最合适的路线，不堵车不绕路？我们用搜索引擎搜索我们想要的内容，如何通过关键字匹配最优结果呈现出来？这些过程肯定要用到算法。 即日常用的 app 离不开算法，手机离不开 app，而我们离不开手机。 3. 大厂看重它 各个大厂面试都会考察算法与数据结构。诸如国内的腾讯、阿里、百度、字节跳动等等，国外的 Google、Facebook 更是要做好万全准备才可以去面试。 为什么大厂面试必考算法与数据结构？ 因为对于大厂来说，把你招进来不仅仅要看你当下的实力，更看重你的长期成长，也就是有没有潜力。而正如第一点所说，计算机基础是内功、地基，它决定了你的技术天花板，也就是你的技术潜力。 我们都希望能够了解框架原理和设计思想，不满足于仅仅做一个 API 调用者。而了解算法与数据结构之后，有助于我们理解框架中一些数据结构和算法的选用原因。 如果你希望做个泛泛之辈，那代码能跑就行可能符合你的选择。但如果你希望自己的代码能够不断精进，那除了代码风格、设计模式之外，对性能和内存占用也要做到一定要求。而算法与数据结构能够给你更多的思路和工具去提升性能、降低内存。 算法与数据结构包括哪些内容？ 简略版 如果你目标是入门，或者急于面试，掌握 10 个数据结构、10 个算法足以。 10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 数。 10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分支算法、回溯算法、动态规划、字符串匹配算法。 完整版 完整版则包含较多内容，不再一一罗列，参考思维导图内容。 如果你需要文中思维导图，可以关注公众号 AndroidRain 回复 算法与数据结构 获取 xmind 源文件。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"算法与数据结构/算法与数据结构 2：如何学习.html":{"url":"算法与数据结构/算法与数据结构 2：如何学习.html","title":"算法与数据结构 2：如何学习","keywords":"","body":" 在上文 算法与数据结构（一）开篇 中讲了为什么学习算法与数据结构和它包括哪些内容。 概括来说，掌握算法与数据结构之后，我们会更容易跟上计算机潮流、更快了解其他框架底层原理、更可能进入理想的公司。 它包括： 时间复杂度分析； 空间复杂度分析； 十个核心算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分支算法、回溯算法、动态规划、字符串匹配算法； 十个核心数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 数。 算法简单来说就是处理数据的方法，数据结构为表示、存储数据的结构。算法和数据结构相辅相成。 其中复杂度分析是重中之重，任何代码在理论上分析其性能都离不开复杂度分析。算法的主要目标是在如何更好的节省 CPU、内存资源的情况下，处理数据解决问题。而我们又不可能每次通过在机器上跑一下的方式来衡量一个算法。这就需要用到复杂度分析。而且在学习排序、查找等算法时，也必然会常常用到复杂度分析。 对于一个数据结构或者算法，我们也要去了解其发展历史、自身有什么特点、和另外一个相比有什么异同、适合的问题场景、有什么实际的应用等等。这样才能从多个维度去了解一个知识点，更好的掌握记忆。 学习数据结构和算法只需要有高中数学和基础编程知识即可。 1. 实践：一定要动手写 碰到一个排序算法或者查找算法，一定要自己尽量在不看示例代码的情况下先写一遍。然后和示例代码对比，思考自己没有考虑到的细节和自己代码上能够优化的点。然后在自己多写几遍，同时结合 LeetCode 上的题目，做两三道相关题目。 近年来，无论是一万小时定律，还是刻意练习。都在强调练习、实践的重要性。通过练习，一方面是肌肉记忆加深印象；另一方面，只有在练习过程中，你才能触碰到知识点的细节，让你对其有所思考，进而加强相关的神经细胞。 2. 总结、分享 在学完知识之余，也要花工夫去总结和分享。在这个过程中，你会发现自己薄弱的地方。因为分享时你需要去考虑对方是否能够理解你讲的内容，曝露出自己的不了解的知识之后，你就会去补足这个缺少的知识，这样不断的慢慢的完善自己的知识体系。 分享出去之后，也能够和读者碰撞出一些思维的火花。已有的想法通过碰撞，产生新的想法，这是一件令人激动的事情。 费曼学习法中所强调的就是学习之后一定要教给别人，通过自己做老师这个过程，不断的让自己对这个知识点产生更加深入的理解、更加全面的理解，最终达到深入掌握知识的目的。 3. 慢慢来 学习不像打游戏，会不断获得反馈，这恐怕是打游戏停不下来的一个重大因素。任何知识的学习都需要一个沉淀的过程，你不可能一口吃成一个胖子。 碰到问题时一定不要气馁和怀疑自己。因为碰到问题这时每个人都会遇到，你并不孤独。有很多事情我们当时不能理解，可以先把它放下，等一段时间的消化之后再来看看可能就会恍然大悟。这个时候你需要换个角度来看问题，我们一生会碰到很多问题，很多需要死磕才能解决的问题。这个时候就需要跨过去这个坎，掌握这个知识、工具，那就可以在以后的人生里使用它，这样看来，投入的那些精力是不是相当划算。 4. 使用工具 最后，为了帮助大家更好的学习数据结果与算法，我开发了一个可视化小程序。在这个小程序上你可以可视化的看到比如快速排序算法的执行过程，把枯燥的代码形象的展示或许会更好的帮助你学习。 微信搜索 VisualLearning 即可体验。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"算法与数据结构/算法与数据结构 3：数组与链表.html":{"url":"算法与数据结构/算法与数据结构 3：数组与链表.html","title":"算法与数据结构 3：数组与链表","keywords":"","body":" 这次来说说数组与链表。在说数组与链表之前，先来介绍一下线性表和非线性表。 线性表 LinearList 顾名思义，线性表的结构是线性的。就像图书馆书架上的书一样，每一行的书都是整齐的排列在直直的书板上。高楼在垂直方向上也可以说是线性的，每一层楼都可以看作是一个单位，依次上下排列。 说到线性表的本质，就是每个元素之间，只有前后关系。书架上的书，相邻的两本书，其中一本必然在另一本的前边或者后边（不考虑上下层）。相邻的两层楼，其中一层必然在另一层的上边或者下边。 由此看来，数组、链表都属于线性表，另外栈、队列也属于此类。 非线性表 与线性表对应的就是非线性表。非线性表的每个元素之间关系更加多元，不只是有前后关系。 一棵树，树干长出树枝，树枝又可以分叉，最后长出树叶。那树枝之间有父子关系、兄弟关系。一张地图，主要地点之间的关系则更加复杂。 数据结构中的树、图等都是非线性结构。 数组与链表 先来看一张图。 这是一个抽屉柜。但这也能够反应硬盘空间的结构。抽象来看，硬盘本质上就是一个一维的、每个元素相等大小紧密排列的结构，虽然硬盘我们看到是一个 3D 实物，但最终总能够映射成一维的空间。 数组则完全是硬盘结构的映射，使用连续的内存空间存储数据。可以说数组这种数据结构在使用内存上非常直接，申请一块连续的内存空间，然后存储数据即可。就好像 a、b、c 三人的房屋在一条街上各自相邻，去完 a 家，往右走两步就是 b 家，再走两步就是 c 家。 但是这也带来了一个核心问题——如果内存中没有一块连续的内存空间可供使用怎么办。在内存中我们运行着操作系统和众多软件。软件运行会加载到内存中，结束时会释放掉。经过反复的这个过程，我们的内存空间会变得十分零碎。很可能空余的空间有 100 个空位，但是这 100 个空位是不连续的、被其他正在使用中的内存分割开的，那我们申请 100 个空间的数组时也会失败。 这也导致了链表的产生。 链表为了解决数组强制要求分配连续空间的问题，通过在当前元素中记录下一个元素地址的方式，将多个分散在内存空间中的元素联系起来。就好像 a、b、c 三人的房屋并不是相连，而是隔了很远，但是 a 知道 b 家的地址，b 又知道 c 家的地址，这样我们只要知道 a 的地址，总能找到 b、c 的位置。 天下没有免费的午餐，链表虽然不需要连续的内存空间，但是每个元素需要记忆下一个元素的位置，这增加了链表单个元素的空间占用。相当于链表通过单个元素的空间占用来解绑整体内存空间连续的强制要求。算法与数据结构中充满了这种 Trade-Off。 总结一下，数组要求内存空间连续，但是只要通过简单的 base_address + k * size 的方式，就能够马上访问第 k 个元素，即具有 O(1) 随机访问的能力。链表不要求内存空间连续，但是需要从头开始，一个个依次访问元素之后才能够找到第 k 个元素。 对比 不管是数组还是链表，我们对其进行操作一般包括：插入数据、删除数据、查找数据。接下来我们通过这三个操作来对比一下两者。而分析的时候必然会涉及到时间复杂度，我们先来简单说说时间复杂度如何分析。 时间复杂度 我们一般会使用大 O 表示法来作为时间复杂度分析的工具，或者说表示方式。我们在进行时间复杂度分析时，并不关注算法的实际执行时间，而是关注代码执行时间在数据规模增长时的变化趋势。简单来说，我们分析的是在数据规模 n 下，代码的执行次数。最后用大 O 表示法表示。 结合如下伪代码，介绍一下其分析方法： 只关注循环执行次数最多的代码，忽略其常量、低阶、系数; 加法法则：一段代码的总复杂度，等于量级最大的那段代码的复杂度； 乘法法则：嵌套代码的复杂度等于内外代码复杂度的乘积。 complexity(int n) { int[] array = new int[n]; // 1: O(1) int a = array[0]; int b = array[1]; // 2: O(n) for (int i = 0; i 这里我们的数据量为 n。 首先我们看注释 1 处，虽然这里访问了两次 array，但是我们忽略其常量，所以这段代码复杂度为 O(1)。 我们再看注释 2 处，这里通过循环对数组进行打印了两次，访问了数组的所有元素，所以其代码复杂度为 O(2n)，但是我们会忽略系数，所以这段代码时间复杂度为 O(n)。 我们最后看注释 3 处，通过两层循环嵌套，每个循环均访问了数据所有元素，打印数组元素的乘积，每层循环的时间复杂度为 O(n)，根据乘法法则，这段代码的时间复杂度为 O(n) * O(n)，即 O(n^2)。 那整体来看，这个函数的时间复杂度是多少呢？根据加法法则，同时我们会忽略低阶、常量的时间复杂度，最终我们的时间复杂度为 O(n^2)。 空间复杂度的分析方式和时间复杂度类似，只不过是把代码执行次数换成空间占用。 常见的时间复杂度有：O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(n!)。 接下来我们继续对比数组和链表。 插入数据 数组的插入数据分为两种，一种是有序数组插入后仍要保持数组元素有序，另一种是无序数组插入数据。先来看看第一种，为了保证数组的有序，所以我们需要将插入位置之后的数据往后搬移位置，最优情况是插入数组尾部，无需搬移数据，时间复杂度为 O(1)，最坏的情况是插入头部，需要搬移所有的数据，时间复杂度为 O(n)。平均下来时间复杂度为 O(n)，其平均时间复杂度可以通过权重的方式计算，在此不再详述。对于第二种无需数组则比较简单，假如我们插入的位置为 k，只需将第 k 个元素移到尾部，然后插入数据即可，时间复杂度为 O(1)。 链表的插入就比较简单，直接操作一下元素的指针指向即可，在 O(1) 时间复杂度即可完成。当然这里说的是已经知道插入位置的情况，不包含查找插入位置的过程。 删除数据 数组删除数据时，为了保证占用空间的连续，删除后需要搬移后续数据，所以其时间复杂度为 O(n)。当然这里可以做一下优化，即删除数据后不要马上搬移数据，而是先记录下来，空间不够时再进行一次搬移数据的操作。这个就是 Java 虚拟机垃圾回收机制中 标记清除算法 的核心思想。 链表删除数据也比较简单，直接操作元素的指针指向即可，时间复杂度为 O(1)。 访问数据 假设我们现在要访问第 k 个元素，数组因为空间连续的特性，通过上述地址计算公式直接拿到第 k 个元素的地址，直接访问即可，时间复杂度为 O(1)。链表则比较麻烦，因为其空间不连续，我们需要从头开始，一个一个的依次拿到后续元素的地址，直到第 k 个。所以其时间复杂度为 O(n)。 综上所述，我们可以得到下表。 数组 链表 随机读取 O(1) O(n) 插入 O(n) O(1) 删除 O(n) O(1) 总结 最后我们可以得出结论，数组与链表的主要区别在于内存空间是否连续。数组要求内存空间连续，所以分配内存时条件更加苛刻，但是这让数组能够 O(1) 随机访问元素。链表无需内存空间连续，分配内存的条件比较宽松，但是这导致链表占用空间更大，访问元素时间复杂度较高。 最后推荐一下我正在编写的小程序 VirtualLearning，它能够可视化一些算法与数据结构，让你更直观的学习。目前支持了主要的排序算法，更多内容扩充中，敬请期待。 微信扫码即可体验，或者搜索 VirtualLearning。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"算法与数据结构/算法与数据结构 4：栈与队列.html":{"url":"算法与数据结构/算法与数据结构 4：栈与队列.html","title":"算法与数据结构 4：栈与队列","keywords":"","body":" 上次聊到数组与链表，它们都是线性表，数组与链表的本质区别是内存是否连续，进而得出结论：数组可以在 O(1) 时间复杂度进行随机访问，但是对内存要求严苛；链表访问元素时间复杂度为 O(n)，但是对内存要求低。 今天来介绍另外两个线性表中的数据结构：栈和队列。 栈 Stack 栈是一种线性表，只有前后关系，但是相对于数组和链表来说，其元素的操作是受限的。栈只允许在一端进行元素的插入、删除操作，往栈中放入元素我们称之为压栈操作，从栈中取出元素我们称之为出栈。我们可以把栈看作是一个一端开口的羽毛球筒，我们压栈、出栈操作数据的过程，就是我们从筒中放入、取出羽毛球的过程。当然，栈是一种抽象的数据结构，我们在实现它时，既可以使用数组，也可以使用链表。 接下来我们看一下栈的使用情景。 浏览器网页前进后退 我们经常会使用浏览器浏览网页，网页中有很多超链接可以跳转到下一个页面。而有时我们希望能够返回上一个页面继续浏览，再返回上一个页面之后，我们还可能再回到刚才的子页面。 使用两个栈就可以实现这种能够随意前进后退的网页浏览了。 我们把一开始打开的网页压栈放入栈 a，如果此时点击网页中的链接查看下一个页面，那我们把子页面继续放入栈 a。当我们返回时，把子页面从 a 中出栈，放入栈 b。这个时候我们关闭页面，继续从 a 中出栈放入栈 b 即可。如果我们点击前进按钮，则去栈 b 中出栈即可。也就是说，如果我们把依次打开过的网页放入栈 a 维护，回退的界面放入栈 b 维护。点击后退按钮时，查询栈 a，有页面则出栈，放入栈 b，没有则无法后退；点击前进按钮时，查询栈 b，有页面则出栈，没有则无法前进。 函数调用栈 基本每一个编程语言中，都存在函数的概念。一个函数可以调用另外一个函数，那么函数之间的调用是如何实现的呢？也是用栈。 以 Java 为例，我们编写 Java 代码之后，是编译为 class 字节码，然后交给 Java 虚拟机执行。在 Java 虚拟机中，是使用一个栈来完成函数调用的，每一个函数在栈中所占有的空间称为栈帧。Java 入口函数为 main 函数，执行时先将 main 函数入栈，此时栈帧中会保存该函数的局部变量、操作数栈、动态连接、方法返回地址等内容。当 main 函数调用一个子函数 add 时，虚拟机会继续将 add 函数相关内容压入栈顶，add 函数执行完毕后会出栈，此时 main 函数处于栈顶，会继续执行 main 函数。 这个例子我们可以看到，对于基础数据结构的理解，可以帮助我们了解平时常用语言、框架的实现细节，对于我们深入学习计算机知识很有帮助。除了以上两个例子之外，栈还可以用来做表达式求值、括号匹配等，感兴趣的话可以自行了解。 队列 Queue 队列和栈一样，也是一种操作受限的线性表数据结构。栈只能在一端进行插入和删除操作，队列则是在一端进行删除操作，称为出队，在另一端进行插入操作，称为入队。 和栈一样，队列也可以使用数组或者链表来实现。当我们使用数组来实现时，需要维护两个变量 head、tail 标识队列的头部和尾部。入队时，元素放入数组现有元素的末尾，tail 往后移动一位。出队时，首个元素删除，head 往后移动一位。此时会出现这样一种情形：当我们经过不断的入队和出队之后，head、tail 会不断的往后漂移，当 tail 到达数组尾部时，没办法再进行入队操作，但是很可能 head 之前还有空间。这就导致空间浪费。此时我们可以通过每次出队都把所有数据往前搬移一位，也可以通过 tail 到达数组末尾时，搬移所有数据到数组头部解决问题，但是频繁的搬移操作会浪费性能。 由此导致了循环队列的产生。循环队列的关键是，把数组看成一个环状结构。head、tail 到达数组末尾时，仍可以回到头部的位置。此时使用 tail 尾部这个词就不太合适，改用 rear 后部更好。如下图，入队出队的过程，就是操作 head、rear 位置的过程。在这个环中，我们可以不断的转圈修改其位置，而不会出现上述局面，也就把我们从频繁搬移数据中解绑，减少性能消耗。 但是我们的底层实现还是数组，这里的关键问题有两个： 如何在 rear 到达数组尾部时，处理 rear 的位置？ 如何判断队空和队满？ 对于第一个问题我们可以使用求余操作来解决问题。普通队列我们是直接 rear++ 操作位置，现在我们改成 rear = (rear + 1) % array.length - 1 来操作即可。当然 head 也是如此。 对于第二个问题，普通队列我们通过 head == 0 && tail == array.length 来判断队满，head == tail 来判断队空。循环队列还是使用 head == tail 判断队空，队满的条件就要改成 (tail + 1) % array.length == head。 另外一种队列是阻塞队列。阻塞队列就是在队列基础上增加了阻塞操作。当队空的时候，从队列取出数据时会阻塞；当队满时，在队列中插入数据会阻塞。可以发现，阻塞队列跟我们常说的 生产者-消费者模型 逻辑基本一致。 还有一种比较常用的队列是优先队列，即优先级更高的元素优先出队，该队列的实现涉及到完全二叉树、大顶堆、小顶堆相关知识，我们后续会涉及到。 总结 我们可以看到栈和队列是一种抽象的数据结构，定义一种操作规则，然后应用到对应的场景之中。这两种数据结构的操作规则和其应用场景是契合的。我们在学习算法和数据结构时，了解其优点和缺点，进而了解其应用场景是十分重要的。没有最好的数据结构和算法，只有在某种场景下更加适合的数据结构与算法。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"算法与数据结构/算法与数据结构 5：哈希表.html":{"url":"算法与数据结构/算法与数据结构 5：哈希表.html","title":"算法与数据结构 5：哈希表","keywords":"","body":" 在讲哈希表之前，我们先来看看往一个数组插入数据的过程。 确认插入数据的下标； 把数据放入数组。 拿日常生活中根据身高排队的例子来说，我们想获取到从低到高的姓名列表。我们就是在重复这样一个过程： 找到剩余队伍中身高最低人的姓名； 放入当前数组元素的末尾； 重复上过程。 但是这里有很大的限制，就是我们这种情况下能够知道一个姓名对应数组的下标是多少，很多其他情况下是无法知道的。在这种情况下使用数组处理这个场景是足够的。 然后看看这样一个场景，我们需要存储一个人的姓名及其对应的身高。这个时候我们用数组会怎么做？我们可以把数组存储的元素改成是 (姓名, 身高)，然后我们查找一个人的身高时，遍历数组找到姓名，然后返回身高。这种做法问题是查找时间复杂度过高，每次查找有 O(n) 的复杂度。我们能不能在 O(1) 的时间复杂度中查找到元素呢？ 这时候就需要哈希表 HashTable。 什么是哈希表 哈希表 HashTable，也叫散列表、映射、字典等等，哈希表存储的是键值对 —— key、value。 也就是说，哈希表可以直接存储 \"name\": height 来解决上述问题。 哈希表关键点有三个： 哈希函数 哈希冲突 装载因子 哈希函数 接下来我们结合上图解释一下哈希函数。 我们现在要往哈希表中放入 (\"xiaoming\", 175) 这组数据。发生了什么事情呢？ 首先，数据的 key = \"xiaoming\" 会经过哈希表的哈希函数，转换成数组的下标 i。然后，我们把 value = 175 存储到 array[i] 的位置。 这里的哈希函数要满足几个特性： 相同的 key 经过哈希函数之后的输出一致； 不同的 key 经过哈希函数之后的输出不同； 哈希函数产生的输出在数组的有效范围内。 当我们在哈希表中查询 \"xiaoming\" 的身高时，哈希函数先计算该 key 对应的数组下标，然后取出数组中的数据。 这里我们可以看到，哈希表 = 哈希函数 + 数组，哈希表其实是数组的一种扩充，是由数组演化而来的，解决数组所无法解决的问题。这里我们也再强调一下，没有一种最优的数据结构和算法，只有更加适合某种场景、解决某种问题的数据结构和算法。 后续我们可以看到，哈希表也可能是另外一种形式：哈希表 = 哈希函数 + 数组 + 链表。 哈希冲突 你可能会想到，在我们存储过程中，虽然我们能够通过哈希函数得到一个 key 的整数值，但是我们的数组是有限的，假设这里的整数值为 k，数组长度为 n。我们通过 k % n 取余操作拿到 k 实际的数组下标。我们就会碰到两个整数对 n 取余之后的下标是相等的情况。比如 3 % 2 == 5 % 2 的情况。这个时候如果数组这个位置已经放置了元素，我们该怎么处理呢？ 因为是哈希函数输出的值产生了冲突，所以这种情况我们称之为哈希冲突或者哈希值冲突。 而对应的解决办法有两种： 开放寻址法 链表法 开放寻址法 开放寻址法中有线性探测法，该方法是说在发生冲突时，我们就依次在数组中往后查找，直到找到一个空闲位置。但是这种方法，在我们插入数据越来越多时，发生冲突的可能性就越来越大，线性探测时间也就越来越长。这时哈希表的插入、查找时间复杂度会退化，最差情况是 O(n)。Java 中的 ThreadLocalMap 使用此方法来解决哈希冲突。 当我们采用线性探测法时，如何对以上问题做出优化呢？ 此时我们就要引入装填因子的概念，装填因子 = 已有元素个数 / 散列表的总长度。首先我们确定一个装填因子，然后当目前的因子大于我们设定的装填因子时，我们就对数组进行扩容，以此来保证有一定的剩余空间，进而减少线性探测时的时间复杂度。装填因子的设置也需要根据情况来看，要对线性探测的执行效率和扩容的成本上进行平衡。本质上还是时间、空间的平衡，当我们要求哈希表执行效率更高时，我们就可以设置更小的装填因子，增大剩余的数组空间，有利我们更快的进行线性探测；当我们内存比较紧张时，就需要设定更大的装填因子。 还有一种开放寻址法是双重散列。当一个哈希函数输出的下标值发生冲突时，采用另外一种哈希函数来重新计算下标值，直到找到空闲的位置。 链表法 链表法另辟蹊径，它把数组存储的元素改为链表，当发生冲突时不再尝试把数据存入到数组中，而是存储到同一下标的链表之中。上图展示了链表法的哈希表结构。这时我们发现 哈希表 = 哈希函数 + 数组 + 链表。Java 中的 LinkedHashMap 使用了链表法解决冲突问题。 当我们插入数据时，相当于在链表中插入元素的时间复杂度 O(1)。当我们查询时，取决于对应链表的长度 m，时间复杂度为 O(m)。 但是对于黑客来说，这种方法存在一个致命漏洞。黑客可以不断的往哈希表中放入 key 对应下标相同的数据，这会导致数组中只有该位置有长长的链表，进而导致查询时间十分漫长，对你的程序产生攻击的效果。我们称之为哈希表碰撞攻击。 所以一个能够产生均匀下标值的哈希函数十分重要。除了采用更优的哈希函数，我们还可以对链表做优化，比如说改造成红黑树解决查找过慢的问题。其实 Java 8 中就做了这个优化。 经过以上分析，我们知道开放寻址法更加适合数据量比较小、装填因子较小的场景，这也是 Java 中 ThreadLocalMap 使用开放寻址法的原因；链表法比较适合存储数据量比较大、对象比较大的情况。 什么是好的哈希表 结合上述内容，我们知道一个好的哈希表要有以下特性： 快速的查询、插入、删除 性能稳定，不能够退化的太严重 内存占用合理 要保证以上特性，需要做到： 哈希函数的输出比较均匀 合适的装填因子大小，高性能的动态扩容 合适的哈希冲突解决方法 总结 我们除了要了解哈希表是存储键值对的数据结构之外，还要掌握插入、删除、搜索一个数据的发生过程是怎样的。另外我们也要掌握哈希表的三个关键要素：哈希函数、冲突解决方法、装填因子。最后，我们要根据自己的实际场景，通过调整确定三个关键要素，选择合适的哈希表或者实现自己的哈希表。 实践 最后，推荐大家做一下 Leetcode 上的题目。可以先用自己的思路写一下代码，然后结合使用哈希表的方式再写一份代码。最后比较这两者的时间空间复杂度。 有效的字母异位词 两数之和 三数之和 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"算法与数据结构/算法与数据结构 6：二叉树基础篇.html":{"url":"算法与数据结构/算法与数据结构 6：二叉树基础篇.html","title":"算法与数据结构 6：二叉树基础篇","keywords":"","body":" 不同于数组、队列等线性表的数据结构，树是一种非线性结构。除了树之外，图也是一种非线性结构。 二叉树如下所示。 节点和边 在树中由节点和连接节点的边组成，二叉树最多有两个子节点。关于节点有几个概念： 父节点：节点 1 为节点 2 和 3 的父节点； 子节点：节点 4 和 5 为节点 2 的子节点； 兄弟节点：节点 2 和 3 为兄弟节点； 叶子节点：没有子节点的节点为叶子节点，如节点 4 和 5； 根节点：没有父节点的节点为根节点，如节点 1。 关于树的层级有如下几个概念： 节点的高度：该节点到叶子节点的最长路径，即边数； 节点的深度：根节点到该节点经历的边数； 节点的层数：深度 + 1； 树的高度：等于根节点的高度。 以下图为例，可以帮助理解节点高度、深度、层的概念。 特殊的二叉树 如果一个二叉树叶子节点都在同一层级，而且除了叶子节点每个节点都有两个子节点，这种二叉树叫做满二叉树。上文中的图例即为满二叉树。 如果一个二叉树，最后一层的叶子节点都在左侧，其他层的节点数量达到最大，这种二叉树叫做完全二叉树。上文图中我们把节点 7 去掉，就符合满二叉树的条件。 二叉树的存储 二叉树的存储也离不开最基础的数据结构： 数组 链表 对于数组存储，我们可以使用以下规则约定每个节点在数组中存储的位置。 假设父节点存储索引为 i； 该节点左子节点的位置为 2 i，右子节点为 2 i + 1； 根节点存储在 1 号位。 下图可以帮助理解二叉树数组存储的方式。可以看到，完全二叉树使用数组存储能够充分利用数组空间。非完全二叉树则会导致数组空间的浪费。 对于链表存储，我们使用如下结构进行构建二叉树。 class Node { Node leftChild; Node rightChild; } 二叉树的遍历 树和图的遍历分为两种： 深度优先遍历：如果存在层级更深的子节点，优先遍历该节点，否则遍历同层级的其他节点； 广度优先遍历：如果存在同层级的兄弟节点，优先遍历兄弟节点，否则遍历子节点。 对于树的深度优先遍历，又分为三种： 前序遍历：访问当前节点——访问左子树——访问右子树； 中序遍历：访问左子树——访问当前节点——访问右子树； 后序遍历：访问左子树——访问右子树——访问当前节点。 仍以下图为例，其遍历序列分别如下： 前序遍历：1, 2, 4, 5, 3, 6, 7； 中序遍历：4, 2, 5, 1, 6, 3, 7； 后序遍历：4, 5, 2, 6, 7, 3, 1。 三种遍历的递归代码如下。 void preOrder(Node root) { if (root == null) return; print(root) preOrder(root.left); preOrder(root.right); } void inOrder(Node root) { if (root == null) return; inOrder(root.left); print(root) inOrder(root.right); } void postOrder(Node root) { if (root == null) return; postOrder(root.left); postOrder(root.right); print(root) } 总结 本次我们了解了二叉树的基础知识，有二叉树的特征、二叉树的数组和链表存储方式、二叉树的遍历。有时间我们聊聊二叉树的应用，它是如何优化搜索算法复杂度的。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"编译原理/编译原理 1：概要篇.html":{"url":"编译原理/编译原理 1：概要篇.html","title":"编译原理 1：概要篇","keywords":"","body":" 程序代码要想运行在计算机之上，必须要转换为机器语言才行。而负责这项翻译工作的程序为编译器。与之不同的解释器不是通过翻译的方式生成目标程序，而是通过直接执行一行行程序代码来运行。 C 语言是编译型语言，Java 则结合了两种方式，一方面解释执行字节码，另一方面会采用 JIT 的方式将字节码编译为机器语言执行。 编译原理即是源程序映射为目标程序的原理和技术。从单词、空格组成的代码，转译为可以运行在 CPU 之上的机器代码，一般来说要经历以下流程。 词法分析 词法分析的目的是将字符流转换为符号流。以下述程序为例： int add(int a) { int b = a + 3; return b; } 其词法分析的效果如下： 生成的符号给到语法分析阶段使用。同时会生成对应符号表，用于后续的语义分析和代码生成阶段使用。 词法分析过程可以通过模拟有限自动机来实现，有限自动机问题又等价于正则表达式，所以我们又可以借助正则表达式来实现。 语法分析 语法分析的目的是将符号流转换为语法树。上述代码中表达式 b = a + 3 的转换效果如下。 该语法树后续用于分析源程序和生成目标程序。 语法分析需要使用上下文无关的文法来描述程序语法结构，是对正则文法（线性文法）的一次升级。 语义分析 语义分析的主要工作是根据语法树和符号表检查程序是否符合语义规则，同时收集一些类型信息更新到语法树和符号表中。这一部分工作是和上下文有关的，比如数组的下标必须为整数类型的校验等工作。 中间代码生成和优化 中间代码的生成主要目标是用于分析和优化或直接解释执行。比如 Java 字节码属于后者。中间代码 IR 的表示方式有很多种，语法树就是其中一种。 中间代码优化是为了得到性能更好的代码。可以采用诸如常数折叠、消除不可达代码等方法进行优化。 目标代码生成和优化 目标代码生成是指生成特定平台的机器代码。 首先要考虑特定平台不同指令的选择，要选择代码最低的指令进行翻译。然后由于 CPU 支持指令的流水线执行，所以我们可以对指令进行排序，以得到最佳的执行速度。另外还需要考虑对寄存器的分配问题，通过尽量访问寄存器而非内存来得到最快的读取速度。 总结 在源代码编译为目标代码过程中，我们一般分为两个阶段：分析和生成代码。其中分析部分我们称为前端，生成代码部分我们称为后端。前端包括：词法分析、语法分析、语义分析，用于得到程序的语法树和符号表；后端包括中间代码生成和优化、目标代码的生成和优化，根据语法树和符号表对代码进行优化和输出。 参考资料 《龙书》 编译原理之美 编译原理实战课 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"编译原理/编译原理 2：词法分析.html":{"url":"编译原理/编译原理 2：词法分析.html","title":"编译原理 2：词法分析","keywords":"","body":" 什么是词法分析？ 词法分析是编译原理中一个重要的部分，也叫做 字面翻译（Literal Translation），用于把源程序中的单词转换成 形式化语言（formal languages） 中的有效单词。词法分析的目的是把输入的字符流分割成有意义的词素（Token），构成一个 词法单元（Lexical Unit），这个分析过程称为词法分析。 词法分析是编译器的一个重要过程，它的输入是一个符号流（以字符的形式），输出是拆分成有意义的词素，可以对符号流施加上语义上的约束，可以有效的检测出程序中出现的语法错误等。 词法分析的基本概念 词法分析的基本概念是由标记，记号，字符和词素组成的。 标记（tag） 是识别一类特殊标记的函数，如一个空格，一个分号，等等。 记号（symbol） 指一系列字符的集合，比如一个字母，一个关键字，一个标识符等。 字符（character） 指原始的符号，比如英文字母abc、数字123等等。 词素（Token） 是源程序中的一个有意义的词，比如变量名、关键字等等。 词法分析器就是把源程序中每一个字符重新组合成有意义的词素。 例子 下面这段源程序代码： //计算2+2的和 #include int main() { int result=2+2; printf(“2+2=%d\\n”,result); return 0; } 它的词法分析结果如下： Token 含义 #include 关键字 标识符 int 关键字 main 标识符 ( ) 操作符 { } 操作符 int 关键字 result 标识符 = 操作符 2 数字常量 + 操作符 2 数字常量 ; 操作符 printf 标识符 ( ) 运算符 “,result” 字符串常量 ; 操作符 return 关键字 0 数字常量 ; 操作符 } 操作符 我们再看一段示例代码。 //A sample C program #include int main(void) { printf(\"Hello world!\\n\"); return 0; } 它的分析过程如下： 首先使用注释忽略第一行； 第二行的include是一个关键字，表明要引入外部代码； 第三行的int是一个关键字，表示main函数的返回类型； \"main\"是一个标识符，表示函数的名称； \"(\"和\")\"分别是一个界定符，标识main函数的开始和结束； \"printf\"是一个标识符，表示调用函数； \"(\"和\")\"分别是一个界定符，标识调用函数的开始和结束； \"'Hello world!\\n'\"是一个字符串，表示要输出的内容； \"return 0\"是一个关键字，表示函数的返回值。 由此可见，词法分析就是把有意义的单词进行分离，从而将源代码中的抽象概念抽象成具体的有意义的单词，使得编译器可以处理和理解它们，并为程序准备好解释和执行步骤。 本文由 AI 生成。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"计算机网络/计算机网络基础.html":{"url":"计算机网络/计算机网络基础.html","title":"计算机网络基础","keywords":"","body":"计算机网络基础 网络基础基本是围绕OSI七层模型或者是 TCP/IP 模型展开的，主要包括各层名称及功能、每层有哪些协议。 应用层：（HTTP、DNS等） HTTP报文格式、头部有哪些字段 HTTP状态码 HTTP和HTTPS的区别 HTTPS中SSL/TLS加密的握手过程 HTTP一次连接的具体过程 GET、POST的区别 DNS解析过程 Cookie、Session原理 传输层：（TCP、UDP等） TCP/IP四层模型（和OSI的层次对应关系） TCP三次握手、四次握手的过程，状态变化和原因 TCP、UDP区别 TCP拥控、流控原理 Socket原理 以下是正文，其中空出的标题是我目前还没有整理完毕，或者是整理不够完整的内容。在对应内容完善后会进行更新。其中包括Cookie、Session原理，TCP拥控、流控原理，Socket原理。 OSI七层模型及其功能 层级 功能 应用层 允许访问OSI的手段 表示层 对数据进行翻译、加密、压缩 会话层 建立、管理、终止会话 传输层 提供端到端的可靠报文传递和错误恢复 网络层 负责数据包从源到宿的传递和网际互联 数据链路层 将比特币组装成振和点到点的传递 物理层 通过媒介传输比特，确定机械及电气规范 TCP/IP 四层模型及对应协议 TCP/IP中的应用层对应OSI中的应用层、表示层、会话层，网络访问层对应OSI中的数据链路层和物理层。 层级 协议 应用层 HTTP、DNS、FTP、WWW 传输层 TCP、UDP 网络层 IP 网络访问层 ARP 注：DNS作用是将域名转为IP地址；ARP作用是将IP地址转为MAC地址 HTTP报文格式、头部有哪些字段 先说一下HTTP。HTTP：HyperText Transfer Protocol 超文本传输协议，处于应用层，基于请求响应模式，无状态协议。URL：Uniform Resource Location 统一资源定位符，就是常说的网页地址。 HTTP报文 请求报文 报文头部 请求行：包括请求方法类型：GET、POST等，请求地址，协议版本 请求头部字段 通用头部字段 实体头部字段 其他 报文主体：包括如POST中的请求参数、文件上传数据、邮件传输数据等内容 响应报文 报文头部 状态行 响应头部字段 通用头部字段 实体头部字段 其他 报文主体：包括网页正文等内容 根据上述内容，HTTP头部字段包括： 请求头部字段：补充请求的附加内容、客户端信息、响应内容相关优先级等。有Accept、From、Host等字段 响应头部字段：补充响应的附加内容 通用头部字段：请求报文、响应报文都会使用，包括Cache-Control字段，作用是控制HTTP缓存机制 实体头部字段：补充资源内容的更新时间等 HTTP状态码 状态码 含义 1xx 信息性状态码 2xx 成功状态码 3xx 重定向状态码 4xx 客户端错误状态码 5xx 服务器错误状态码 HTTP和HTTPS的区别 简单来说，HTTPS是加密的HTTP。HTTPS = HTTP + SSL/TLS HTTPS使用SSL/TLS进行加密，这既是它的优点也是它的缺点，加密使HTTPS的安全性大大提高，但是加密的过程也导致通信过程中性能的下降。但总的来说用失去的一点点性能换来极高的安全性是非常值得的，苹果和谷歌也大力支持HTTPS的使用。 HTTPS的关键是加密过程，见下一标题。 HTTPS中SSL/TLS加密的握手过程 以下的C代表Client客户端，S代表Server服务端。 C告诉S：协议版本号，支持的加密方法，以及自己生成的随机数 S确认加密方法，给C方松证书和自己产生的随机数 C确认证书有效性，产生新的随机数，并使用数字证书中的公钥加密随机数，发送给S S使用对应的私钥解密得到C发过来的随机数 C和S使用约定的加密方法，使用前面的三个随机数，生成对话密钥，然后用此密钥加密接下来的整个对话过程 总的来说，整个过程就是使用非对称加密算法交换“对话中要使用的对称加密算法的密钥”，然后使用对称加密算法进行对话。 注： 加密算法分为两种：对称和非对称 对称加密是指对话双方使用同一密钥进行加密和解密。特性是速度快，但存在如何安全确认密钥的问题。 非对称加密是指拥有两个密钥，公钥和私钥。公钥加密的内容只有私钥能够解密，私钥加密的内容只有公约能够加密。C向S发送内容时使用S的公钥加密，这样就只有持有对应私钥的S能够解密。特性是安全，但速度慢。同时存在如何证明公钥是S的问题，因为可能有人从中间劫持，伪装S发送劫持人的公钥。为了解决这个问题，引入了数字证书来保证公钥的有效性。 SSL/TLS结合了两个加密算法的优点，利用非对称加密的安全来交换对称加密的密钥，然后利用对称加密的速度快来对这个会话进行加密。 HTTP一次连接的具体过程 域名解析（DNS）——> TCP三次握手，建立连接 ——> 发起HTTP请求 ——> 服务器响应请求，返回数据 ——> 客户端处理数据 ——> 合适时刻四次握手，断开连接。 这里可能会继续追问诸如DNS解析过程、三次握手四次握手过程和原因等等问题，解答见下文。 GET、POST的区别 GET请求可以被浏览器缓存，POST不可以 POST安全一些，因为GET请求都在URL中，也会被浏览器保存记录；而POST请求可以放到Body中 POST可以用RequestBody传输更多的数据，GET的数据量受到URL长度限制 POST支持更多编码，且不对数据类型限制 GET的目标功能是查询数据，POST的目标功能是修改数据，或者上传数据 DNS解析过程 DNS功能是将域名解析为IP地址。 查找浏览器缓存，是否有解析记录，没有则进入第二步 查找系统缓存，是否有解析记录，没有则进入第二步 给配置的DNS服务器（LDNS）发送请求，LDNS查找到则返回 LDNS没有找到时会请求RootServer，返回一个顶级域名服务器 LDNS请求顶级域名服务器，返回NameServer地址 NameServer返回IP给LDNS，LDNS会进行缓存 LDNS返回给用户 注：各级都会对IP的解析进行缓存，同时会根据各自的缓存策略对一些记录进行清理 Cookie、Session原理 TCP三次握手、四次握手的过程，状态变化和原因 为什么需要三次握手建立连接？为了防止已失效的连接请求报文段突然又传到了服务端，服务端以为要建立连接，造成资源浪费（无效连接）。发生场景是，客户端发送第一个建立连接的请求由于网络原因服务端一开始没有接收到，因此客户端发了第二个连接请求，这个请求成功，建立起了连接。但是第一个请求后来又到达服务端，如果没有第三次确认，服务端将多形成一个连接，造成资源浪费。 为什么需要四次握手断开连接？断开连接时，分为两个阶段。一次是客户端通知服务器，告知自己不会再发送数据。注意，此时服务器仍可以发数据给客户端。第二次是服务器告知客户端自己不会再发送数据。要弄清楚的是，断开时，任意一方都可以主动断开，表明自己不再发送数据，但仍可接收数据。所以中间的FIN和ACK不能合并。另外每次断开连接需要FIN请求 + ACK，所以断开需要四次。 TIME_WAIT等待2MSL的意义？ 确保连接可靠关闭，防止最后一个ACK的丢失。 避免套接字混淆（同一个端口对应多个socket） 注：主要目的是，对客户端会发的ACK丢失的情况做处理，可以在服务端再次发送FIN时回发ACK。 TCP、UDP区别 特性 TCP UDP 有无连接 有 无 数据有序性、完整性 有 无 效率高低 低 高 数据大小 无限制 每个数据包64K 应用方面 可靠通信 不需要可靠通信 TCP拥控、流控原理 Socket原理 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"设计模式/从 Android 源代码来看『观察者模式』.html":{"url":"设计模式/从 Android 源代码来看『观察者模式』.html","title":"从 Android 源代码来看『观察者模式』","keywords":"","body":"从 Android 源代码来看『观察者模式』 这篇文章主要帮助大家理解什么是『观 察者模式』，同时结合Android中ListView和BaseAdapter的源代码来解释一下此模式。 首先，通俗的解释一下什么是『观察者模式』。 『观察者模式』中有两个角色：老板、员工。 老板可以雇佣和解雇员工，可以命令员工去干活。 根据『观察者模式』的字面意思，很可能误解为：『观察者』在检测到『被观察者』发生变化时，自己做出一定反应。 但是，实际上这个『观察者』很懒，说是『观察者』，其实是等到『被观察者』通知他：『我变身了！』，然后『观察者』做出反应。 所以把『观察者』看作『员工』，『被观察者』看作『老板』更为合适，我们也可以叫它『雇佣者模式』吧！ 然后，我们结合代码来看看『观察者模式』。 在Android中，包含了对应观察者模式的两个类：DataSetObserver和DataSetObservable。DataSetObserver便是『观察者』，就是『员工』，DataSetObservable便是『被观察者』，是『老板』。 DataSetObserver.Java：『员工』有两个函数，代表这老板有权利让他干这两种活。因为这里是Android中BaseAdapter要用到的DataSetObserver，所以『员工』只干这两种活。 public abstract class DataSetObserver { public void onChanged() { // Do nothing } public void onInvalidated() { // Do nothing } } DataSetObservable.Java：『老板』可以让雇佣的所有员工干活。另外继承Observable后，『老板』拥有了Observable的雇佣和解雇『员工』的能力。 public class DataSetObservable extends Observable { public void notifyChanged() { synchronized(mObservers) { for (int i = mObservers.size() - 1; i >= 0; i--) { mObservers.get(i).onChanged(); } } } public void notifyInvalidated() { synchronized (mObservers) { for (int i = mObservers.size() - 1; i >= 0; i--) { mObservers.get(i).onInvalidated(); } } } } Observable.Class：『老板』雇佣和解雇『员工』。（实际上是通过ArrayList来保存和移除『员工』的） public abstract class Observable { public void registerObserver(T observer) { ...省略代码 } public void unregisterObserver(T observer) { ...省略代码 } } 以上便是Android源代码对『观察者模式』的准备。两个抽象类和一个具体类描述了『员工』可以干的活和『老板』的权利。 那Android中ListView和BaseAdapter是如何利用『观察者模式』的呢？ 在Android中我们经常要用到 ListView 组件。ListView 是用来显示一列类似的 ItemView 的。而且不同开发者，对 ItemView 的样式的显示效果的要求是不一样的，可谓千种万种。 为此，Android 通过增加 Adapter 层，将 ItemView 的操作都封装到 Adapter 中，然后 ListView 拥有一个Adapter对象，通过调用此对象的接口完成多个 ItemView 的布局。这样来看，Adapter 完成了数据层的操作，ListView 是不用涉及到 ItemView 的数据层的。这种模式其实是『适配器模式』的变种。我们以后再看『适配器模式』。 那当数据发生改变，要更新 UI 的时候怎么办呢？ Android 的做法是，在 Adapter 中添加一个『老板』对象，让 Adapter 拥有『老板』的所有权利。然后在 ListView 中，添加一个『员工』对象（继承 DataSetObserver，在重写父类方法时，更新 UI）。另外在 ListView 的 setAdapter 方法中，将『员工』和『老板』绑定起来，实现『老板』和『员工』的雇佣关系。最后开发者就可以调用 Adapter 的方法，让『老板』命令『员工』干活了！ 接下来我们看一下代码实现。 BaseAdapter.Java： 拥有DataSetObservable对象，就是说Adapter是『老板』的上司，拥有『老板』的所有权利。 public abstract class BaseAdapter { private final DataSetObservable mDataSetObservable = new DataSetObservable(); public void registerDataSetObserver(DataSetObserver observer) { mDataSetObservable.registerObserver(observer); } public void unregisterDataSetObserver(DataSetObserver observer) { mDataSetObservable.unregisterObserver(observer); } public void notifyDataSetChanged() { mDataSetObservable.notifyChanged(); } public void notifyDataSetInvalidated() { mDataSetObservable.notifyInvalidated(); } } ListView.Java： setAdapter()方法中，将 AdapterDataSetObserver 注册到 Adapter 的DataSetObservable中，实现『老板』和『员工』的雇佣关系。 public class ListView { ...代码省略 @Override public void setAdapter(ListAdapter adapter) { ...代码省略 mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); ...代码省略 } ...代码省略 } AdapterDataSetObserver 继承了 DataSetObserver，重写父类函数时，进行更新界面的操作。 『观察者模式』实现了对数据和界面的解耦。 以上就是笔者对『观察者模式』的理解了，若有谬误，敬请指出！谢谢！ Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"设计模式/从 Android 源码来看“ Builder 模式”.html":{"url":"设计模式/从 Android 源码来看“ Builder 模式”.html","title":"从 Android 源码来看“ Builder 模式”","keywords":"","body":"从 Android 源码来看 “Builder 模式” 本文主要解释什么是Builder模式，及其作用。然后结合 Android 源码来看一下Builder模式的实现。 什么是Builder模式 Build 是构建、建造的意思，Builder 模式又称建造者模式。 Builder模式中包括两个核心元素：产品和建造者。这两者可以比作房屋和砖瓦匠。在建造房屋这个过程中，如果建筑公司直接操作房子，除了要对墙壁的颜色、地板的材质、屋顶的形状作出选择外，还要注意建造房屋时的顺序：先打地基、再垒墙壁、最后封顶等等。记住构建房屋的每一步及其顺序，这对建筑公司来说是十分麻烦的。而如果建筑公司引入砖瓦匠的角色，将构建房子的流程等工作交给砖瓦匠，自己只需告诉砖瓦匠：“我要木质地板、白色的墙壁、红色屋顶”即可，构建房屋所涉及的复杂流程就无需关心。另外，当建造房屋的流程发生变化时，建筑公司仍然只需告诉砖瓦匠：“我要木质地板、白色的墙壁、红色屋顶”，而不需作出任何改变。 由上边的比喻可以看出，Builder模式是将房子本身的设计、表示和房子的构建进行分离。不使用此模式，开发者不仅需要关注一个产品的表示，比如AlertDialog的title、button等界面元素，还要关注构建产品的步骤。更加重要的是，如果建造房屋的流程发生变化，不能够再按照以前构建产品的方式创建产品的话，开发者就不得不修改代码来适配新的构建流程。Builder模式可以解决这些问题，为产品增加Builder角色，将构建过程交给Builder实现，开发者只需关心产品属性的设置即可。 就像建筑公司雇佣砖瓦匠需要发工资一样，使用Builder模式的缺点便是需要为增加的Builder对象分配内存。 源码中的Builder模式 在Android源码中，比较常见的是AlertDialog的使用。代码如下： val builder = AlertDialog.Builder(this) builder.setMessage(\"message\") builder.setTitle(\"title\") ... builder.create().show() 以上代码，无论构建AlertDialog的流程如何变化，都无需改动代码。因为构建过程在builder.create()方法中，而create（）方法相对于开发者来说是隐藏的，无需关心的。唯一变化的是create()内部，而这是由Android框架实现的，也就是API发布方进行维护即可。这大大提高了代码的灵活性、可维护性、可扩展性。 AlertDialog的核心代码如下： public class AlertDialog extends AppCompatDialog implements DialogInterface { final AlertController mAlert; protected AlertDialog(@NonNull Context context) { this(context, 0); } @Override public void setTitle(CharSequence title) { super.setTitle(title); mAlert.setTitle(title); } ...//省略部分类似setTitle()的代码 public static class Builder { private final AlertController.AlertParams P; private final int mTheme; public Builder(@NonNull Context context) { this(context, resolveDialogTheme(context, 0)); } public Builder setTitle(@Nullable CharSequence title) { P.mTitle = title; return this; } ...//省略部分类似setTitle()代码 public AlertDialog create() { final AlertDialog dialog = new AlertDialog(P.mContext, mTheme); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); ...//省略部分代码 return dialog; } ...//省略部分代码 } } Builder 是在 AlertDialog 内部实现的静态类，其主要工作便是通过一系列set方法对 AlertController.AlertParams 对象进行设置，AlertParams类中包含了所有AlertDialog视图属性对应的成员变量，比如mTitle、mMessage等等。然后在create()方法中进行AlertDialog的构建。 Builder模式的实现比较简单，但是除了“AlertDialog初始化十分复杂，参数繁多”这种应用场景之外，还可以在以下场景中使用Builder模式： 构建产品时，不同构建顺序会对产品产生不同的效果 构建产品时，不同构建元素会对产品产生不同的效果 相同方法在以不同执行顺序执行时，产生不同结果 总结 Builder模式用于将产品的构建和展示分离。这样开发者就不必知道产品构建细节，只需对产品的外观进行设计、配置即可。无需担心产品构建流程发生变化。其缺点是需要为Builder对象分配内存。但这也是大多数设计模式的共同缺点。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "},"面试/如何写好简历的指北.html":{"url":"面试/如何写好简历的指北.html","title":"如何写好简历的指北","keywords":"","body":"如何写好简历的指北 经过忙碌的校招，发现现在计算机行业竞争真的激烈。在这段时间也对简历、面试、专业技术上做了很多阅读、思考和实践。在简历上，看了教学视频，数篇博客，听了live直播。现在把我阅读的一些东西和自己关于如何写简历的心得总结一下，分享给大家，供参考。 大家都知道，在找工作时，要想进入面试的前提是——把简历写好。 对于简历来说，最重要的东西是内容。简单来说，写好简历就是让简历筛选者明白你和他想招的人在能力上匹配度较高。另外要注意的是，校招简历一般一页，社招简历三页左右，这就要求你能够简洁的突出自己的亮点，不求全面，而求专一。全文做到逻辑清晰无废话。 内容概要： 简历给谁看 简历必备信息 简历优化 要注意的地方 一、简历给谁看 是谁筛选你的简历？ HR。 HR是怎么筛选简历？ 了解各部门招聘需求 获取简历（外部 + 内推） 关键词筛选，扫描式阅读 HR最在意什么内容？ 岗位匹配度 工作、教育经历 专业技能 你的期望，包括工作地点、行业、薪资 二、简历必备信息 基本信息姓名、性别、联系方式、意向岗位、照片（贴照片要谨慎，只能选择清晰的大头证件照）。 工作、项目经历要列举核心经历，练手的就不要写了。经历在时间上由近到远排版。工作信息包括起始时间、公司部门名称、岗位名称职责，关键业绩。项目经历信息包括项目名称、时间、项目角色、研究成果、获奖情况。这部分表达的主要是自己专业技术上的实践，所以写明成果很重要，有数据的支撑也能大大增加可信度。 教育背景 起始时间、学校名称、院系专业、GPA（成绩好的话可以写明成绩和排名）。 相关技能主要包括语言能力、计算机能力、专业证书等。内容不要太广泛，尽量和招聘需求对齐。 工作期望包括地点、行业、薪酬。校招的话薪酬就不要涉及了。 自我描述简洁，不要涉及到自己的缺点，不要表达出自己不行。 附加信息比如博客、Github等等。 校招的话还可以包括： 社团经历：社团名称、职务职责、关键业绩 获奖情况：奖学金、项目获奖、活动获奖、科研论文成果 兴趣爱好：这是让你的形象生动立体的内容，但是要简洁 三、简历优化 优化的主要目标还是简洁的表达自己的亮点，尽可能的匹配到公司的招聘需求。 格式的优化 篇幅不宜过长，校招一页，社招三页内 字体字号统一整齐，颜色、字体不要超过2种 色彩设计简洁大方，黑白也不错 逻辑、布局清晰 不要一份简历打天下 按照岗位要求准备内容，提前做足企业招聘需求的功课。项目经历、技能与公司招聘要求对应上去。另外可以巧用专用词汇，描述核心技术。 站在公司的角度考虑问题 这里是说，要主动表达自己和公司的匹配度。比如描述自己能力的稀缺，和专业技术上的优点；利用数据增强说服力；善于概括总结，简洁清晰的表达；自我描述前置，主动留下一个满意的第一印象；说清楚自己的期望。 四、要注意的地方 不要撒谎，有信用问题是职场禁忌 主要信息缺失、错误 无关信息太多，导致亮点不易被发掘 格式或细节粗糙，不要流水账，不要太个性，不要有错别字和网络词汇 用什么邮箱并不重要 附件名字用“应聘XX职位-X年工作经验-姓名”，也可以加上手机号 不要太谦虚，可以适当美化但不要撒谎 常见问题 没有相关工作经验怎么办？ 关键点是在其他领域找到和当前领域相通的方法和思维模式。社招可以写研究成果或者跨行业的项目，和专业领域相关的都可以进行描述；校招可以写社团，学生会经验，体现相应能力的成功实践等等。 前公司没名气怎么办？ 可以主要谈论实操的经验和价值；谈及一些其他圈子的经历；强调自己在群体中的优异和突出表现。 毕业院校不是一类院校怎么办？ 看所学专业的排名竞争力；突出自己在校的学习和实践表现。 专业不对口怎么办？ 写自己对要工作的业务已经具备的能力，比如证书、学习了什么和收获。 频繁跳槽简历怎么写？ 尊重事实，如果是客观原因，可以简单阐述。 推荐 点击查看简历神器 简历模板可以自己在一些网站上付费购买。 Copyright © qingeneral.github.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-04-08 11:10:32 "}}